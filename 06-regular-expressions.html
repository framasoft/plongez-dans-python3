---
title: Expressions régulières
status: En cours
permalink: regular-expressions.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Expressions régulières - Plongez dans Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>Vous êtes ici&nbsp;: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#regular-expressions>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficulté : <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Expressions Rationnelles</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Certaines personnes, lorsqu’elles ont un problème, pensent «&nbsp;Je sais, je vais utiliser des expressions rationnelles.&nbsp;» − Maintenant elles ont deux problèmes. <span class=u>&#x275E;</span><br>&mdash; <a href=http://www.jwz.org/hacks/marginal.html>Jamie Zawinski</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Plongée</h2>
<p class=f>Récupérer un petit bout de texte d’un gros bloc de texte peut relever de l’exploit. En Python, les chaines ont des méthodes pour rechercher et remplacer&nbsp;: <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code>, etc. Mais ces méthodes sont limitées aux cas les plus simples. Par exemple, la méthode <code>index()</code> recherche une unique chaine prédéfinie, et la recherche est toujours sensible à la casse. Pour faire une recherche insensible à la casse d’une chaine <var>s</var>, vous devez appeler <code>s.lower()</code> ou <code>s.upper()</code> et vous assurer que les chaines recherchées sont dans la casse appropriée. Les méthodes <code>replace()</code> et <code>split()</code> ont les mêmes limitations.
<p>Si votre but peut être accompli avec les méthodes de chaine, vous devriez les utiliser. Elles sont rapides, simples, et faciles à lire&nbsp;; et il y a beaucoup d’arguments en faveur d’un code rapide, simple et lisible. Mais si vous vous trouvez dans un cas où vous devez utiliser beaucoup de méthodes de chaines avec des instructions <if> pour gérer les cas particuliers, ou si vous enchainez les appels à <code>split()</code> et <code>join()</code> pour séparer et recoller vos chaines, vous pourriez avoir besoin d’expressions régulières.
<p>Les expressions rationnelles sont une façon puissante et (plutôt) standard de rechercher, remplacer, et parser du texte avec des schémas de caractères complexes. Même si la syntaxe des expressions régulières est rigoureuse et diffère du code normal, le résultat peut être au final <em>plus</em> lisible qu’une solution faite soi-même utilisant une longue série de fonctions de chaine. Il y a même moyen d’inclure des commentaires dans les expressions rationnelles, donc vous pouvez y inclure une documentation fine.
<blockquote class='note compare perl5'
<p><span class=u>&#x261E;</span>Si vous avez déjà utilisé des expressions dans d’autre langages (comme Perl, Javascript, ou PHP), la syntaxe de Python vous semblera très familiaire. Lisez le sommaire du <a href=http://docs.python.org/dev/library/re.html#module-contents>module <code>re</code></a> pour avoir un aperçu des fonctions disponibles et de leurs paramètres.
</blockquote>
<p class=a>&#x2042;

<h2 id=streetaddresses>Étude De Cas&nbsp;: Adresses Postales</h2>
<p>Cette série d’exemple est inspirée d’un problème réel que j’ai eu à mon travail il y a quelques années, alors que je devais parcourir et standardiser des adresses postales d’un ancien système avant de les importer dans un nouveau. (Vous voyez, je n’invente pas tout&nbsp;: c’est vraiment utile.) Cet exemple montre comment j’ai approché le problème.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH MAIN ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>'100 NORTH MAIN RD.'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH BROAD ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>'100 NORTH BRD. RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[:-4] + s[-4:].replace('ROAD', 'RD.')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import re</kbd>                               <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>               <span class=u>&#x2464;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp></pre>
<ol>
<li>Mon but est de standardiser l’adresse de façon à ce que <code>'ROAD'</code> soit toujours abrégé par <code>'RD.'</code>. À première vue, j'ai pensé que ce serait assez simple d’utiliser la méthode de chaine <code>replace()</code>. Après tout, toutes les données sont déjà en majuscules, dont les cas où ça ne correspond pas ne sont pas un problème. Et la chaine cherchée, <code>'ROAD'</code>, est une constante. Et dans cet exemple dramatiquement simple, <code>s.replace()</code> fonctionne effectivement.
<li>La vie est malheureusmeent pleine de contrexemples. Le problème ici est que <code>'ROAD'</code> apparait deux fois dans l’adresse, d’abord dans le nom de la rue, <code>'BROAD'</code> puis en tant que mot en lui-même. La méthode <code>replace()</code> voit ces deux occurences et remplace aveuglément les deux. Pendant ce temps, je vois mes adresses se faire détruire.
<li>Pour résoudre ce problème avec les adresses qui ont plus d’une sous-chaine <code>'ROAD'</code>, vous pouvez faire quelque chose comme ne remplacer <code>'ROAD'</code> que dans les quatre derniers caractères de l’adresse (<code>s[-4:]</code>), et laisser le reste tel quel (<code>s[:-4]</code>). Mais vous pouvez constater que ça commence à devenir assez lourd. Par exemple, le schéma est dépendant de la longueur de la chaine que vous voulez remplacer. (Si vous voulez remplacer <code>'STREET'</code> par <code>'ST.'</coee>, vous devrez utiliser à la place <code>s[:-6]</code> et <code>s[-6:].replace(...)</code>.) Voulez-vous revenir six mois plus tard et déboguer cela&nbsp;? Je sais que ce n’est pas mon cas.
<li>Il est temps de passer aux expressions rationnelles. En Python, toutes les fonctionnalités liées aux expressions rationelles sont contenues dans le module <code>re</code>.
<li>Jetez un coup d’œil au premier paramètre&nbsp;: <code>'ROAD$'</code>. C’est une expression rationnelle simple qui détecte <code>'ROAD'</code> seulement lorsqu’il est à la fin d’une chaine. Le <code>$</code> signifie «&nbsp;fin de la chaine&nbsp;» (Il y a un caractère correspondant, le chapeau <code>^</code>, qui signifie «&nbsp;début de la chaine&nbsp;».) En utilisant la fonction <code>re.sub()</code> vous recherchez l’expression rationelle <code>'ROAD$'</code> dans la chaine <code>s</code> et la remplacez avec <code>'RD.'</code>. Ceci détecte <code>ROAD</code> à la fin de la chaine <var>s</var>, mais <em>pas</em> le <code>ROAD</code> qui fait partie du mot <code>BROAD</code>, car il est au milieu de <var>s</var>.
</ol>
<aside>^ correspond au début d’une chaine. $ correspond à la fin d’une chaine.</aside>
<p>Pour continuer avec mon histoire de parcourir des adresses, j’ai vite découvert que limiter la détection de <code>'ROAD'</code> à la fin de l’adresse n’était pas suffisant, car toutes les adresses n’incluent pas du tout de désignation de rue. Certaines adresses se terminent simplement par le nom de la rue. Je m’en suis sorti la plupart du temps, mais lorsque la nom de la rue était <code>'BROAD'</code>, l’expression rationnelle aurait détecté <code>'ROAD'</code> à la fin de la chaine en temps que partie du mot <code>'BROAD'</code>, ce qui n’est pas ce que je voulais.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD'</kbd>
<samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>
<samp class=pp>'100 BRD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('\\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'100 BROAD'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>'100 BROAD'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD ROAD APT. 3'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>'100 BROAD ROAD APT. 3'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD\b', 'RD.', s)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'100 BROAD RD. APT 3'</samp></pre>
<ol>
<li>Ce que je veux <em>vraiment</em>, c’est détecter <code>'ROAD'</code> quand il est à la fin d’une chaine <em>et</em> qu’il ne fait pas partie d’un autre mot. Pour exprimer cela dans une expression rationnelle, vous utilisez <code>\b</code>, qui signifie «&nbsp;une frontière de mot doit être ici&nbsp;». En Python, ceci est complexe parce que le caractère <code>'/'</code> de la chaine lui-même doit être échappé. On appelle souvent ça le fléau du backslash, et c’est une des raisons pour laquelle les expressions rationnelles sont plus faciles en Perl qu’en Python. En même temps, Perl mélange expressions rationnelles avec la syntaxe classique, donc si vous avez un bogue, c’est plus difficile de dire s’il vient de la syntaxe ou de l’expression rationnelle.
<li>Pour contourner le fléau du backslash, vous pouvez utiliser ce qui est appelé une <i>chaine brute</i>, en préfixant la chaine avec la lettre <code>r</code>. Ceci dit à Python que rien dans cette chaine ne doit être échappé&nbsp;; <code>'\t'</code> est un caractère de tabulaton, mais <code>r'\t'</code> est vraiment le caractère backslash <code>\</code> suivi de la lettre <code>t</code>. Je recommande toujours d’utiliser des chaines brutes lorsque vous utilisez des expressions rationnelles&nbsp;; sinon les choses peuvent devenir confuses très vite (et les expressions rationnelles le sont déjà suffisament).
<li><em>*pfiou*</em>  Malheureusement, j’ai vite trouvé d’autres cas qui contredisaient ma logique. Dans ce cas, l’adresse contient le mot <code>'ROAD'</code> seul, mais il n’est pas à la fin, car l’adresse a un numéro d’appartement juste après la désignation de la rue. Parce que <code>'ROAD'</code> n’est pas exactement à la fin de la chaine, il n’est pas détecté, donc tout l’appel à <code>re.sub()</code> est inutile et vous récupérez la chaine de départ, ce qui n’est pas ce que vous voulez.
<li>Pour résoudre ce problème, j’ai supprimé le caractère <code>$</code> et j’ai ajouté un autre <code>\b</code>. Maintenant l’expression rationnelle «&nbsp;détecte <code>'ROAD'</code> lorsqu’il est en tant que mot à part entière&nbsp;», que ce soit à la fin, au début, ou quelque part au milieu.
</ol>
<p class=a>&#x2042;

<h2 id=romannumerals>Étude De Cas&nbsp;: Les Nombres Romains</h2>
<p>Vous avez probablement déjà vu des nombres romains, même si vous ne les avez pas reconnus. Vous avez pu les voir dans des droits d’auteurs de vieux films et séries («&nbsp;Copyright <code>MCMXLVI</code>&nbsp;» au lieu de «&nbsp;Copyright <code>1946</code>&nbsp;»), ou sur les monuments muraux de bibliothèques ou d’universités («&nbsp;established <code>MDCCCLXXXVIII</code>&nbsp;» au lieu de «&nbsp;established <code>1888</code>&nbsp;»). Vous pouvez aussi les avoir dans des titres ou des références bibliographiques. C’est un système représentant des nombres qui datent de l’ancien empire romain (d’où le nom).
<p>Dans la numérotation romaine, il y a sept caractères qui sont répétés et combinés de différentes façons pour représenter les nombres.
<ul>
<li><code>I = 1</code>
<li><code>V = 5</code>
<li><code>X = 10</code>
<li><code>L = 50</code>
<li><code>C = 100</code>
<li><code>D = 500</code>
<li><code>M = 1000</code>
</ul>
<p>Voici les différentes règles pour construire des nombres romains&nbsp;:
<ul>
<li>Parfois les caractères sont additifs. <code>I</code> est <code>1</code>, <code>II</code> est <code>2</code>, et <code>III</code> est <code>3</code>. <code>VI</code> est <code>6</code> (littéralement, «&nbsp;<code>5</code> et <code>1</code>&nbsp;»), <code>VII</code> est <code>7</code>, et <code>VIII</code> est <code>8</code>.
<li>Les caractères de dizaines (<code>I</code>, <code>X</code>, <code>C</code>, et <code>M</code>) peuvent être répétés jusqu’à trois fois. À partir de <code>4</code>, vous devez soustraire du caractère en cinq suivant. Vous ne pouvez représenter <code>4</code> par <code>IIII</code>&nbsp;; à la place, il est représenté par <code>IV</code> («&nbsp;<code>1</code> soustrait de <code>5</code>&nbsp;»). <code>40</code> est écrit <code>XL</code> («&nbsp;<code>10</code> soustrait de <code>50</code>&nbsp;»), <code>41</code> par <code>XLI</code>, <code>42</code> par <code>XLII</code>, <code>43</code> par <code>XLIII</code>, et enfin <code>44</code> par <code>XLIV</code> («&nbsp;<code>10</code> soustrait de <code>50</code>, plus <code>1</code> retiré de <code>5</code>&nbsp;»).
<li>Parfois les caractères sont&hellip; l’opposé d’être additifs. En ajoutant certains caractères avant d’autre, vous pouvez soustraire de la valeur finale. Par exemple, pour <code>9</code>, vous devez soustraire du caractère de dizaines suivant&nbsp;: <code>8</code> est <code>VIII</code>, mais <code>9</code> est <code>IX</code> («&nbsp;<code>1</code> retiré de <code>10</code>&nbsp;»), et non pas <code>VIIII</code> (puisque le caractère <code>I</code> ne peut être répété quatre fois). <code>90</code> est <code>XC</code>, <code>900</code> est <code>CM</code>.
<li>Les caractères en cinq ne peuvent être répétés. <code>10</code> est toujours représenté par <code>X</code>, jamais par <code>VV</code>. <code>100</code> est toujours <code>C</code>, jamais <code>LL</code>.
<li>Les nombres reomains sont lus de gauche à droite, donc l’ordre des caractères est très important. <code>DC</code> est <code>600</code>&nbsp;; <code>CD</code> est un nombre complètement différent (<code>400</code>, «&nbsp;<code>100</code> retiré de <code>500</code>&nbsp;»). <code>CI</code> est <code>101</code>&nbsp;; <code>IC</code> n’est même pas un nombre romain valide (car vous ne pouvez retirer directement <code>1</code> de <code>100</code>&nbsp;; vous devez l’écrire <code>XCIX</code>, «&nbsp;<code>10</code> retiré de <code>100</code>, plus <code>1</code> retiré de <code>10</code>&#8221;).
</ul>
<h3 id=thousands>Vérifier Les Milliers</h3>
<p>De quoi aurions-nous besoin pour vérifier qu’une chaine quelconque est un nombre romain valide&nbsp;? Prenons les chiffres un par un. Étant donné que les Romains écrivaient du plus grand au plus petit, commençons par le plus grand : les milliers. Pour les nombres supérieurs ou égaux ) 1000, les milliers étaient représentés par une série de caractères <code>M</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106FB58></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106C290></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106AA38></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>      <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106F4A8></samp></pre>
<ol>
<li>Ce schéma a trois parties. <code>^</code> qui correspond au début de la chaine. S’il n’est pas spécifié, le schéma validerait quel que soit l’endroit où les caractères <code>M</code> se trouvent, ce qui n’est pas ce que vous voulez. Ce que vous voulez, c’est que, s’il y a des caractères <code>M</code>, ils soient au début de la chaine. <code>M?</code> détecte <em>au plus</em> un caractère <code>M</code>. Étant donné qu’il est répété trois fois, vous pouvez avoir entre zéro et trois caractères <code>M</code> de suite. Et <code>$</code> correspond à la fin de la chaine. Combiné au caractère <code>^</code>, cela signifique que le schéma doit correspondre à toute la chaine, sans caractère avant ou après les caractères <code>M</code>.
<li>L’essence-même du module <code>re</code> est la fonction <code>search()</code>, qui prend une expression réculière (<var>pattern</var>) et une chaine (<code>'M'</code>) à faire correspondre à lùexpression rationnelle. Si une correspondance existe, <code>search()</code> retourne un objet qui a différentes méthodes pour décrire la correspondance&nbsp;; et si aucune correspondance n’est trouvée, <code>search()</code> retourne <code>None</code>, la valeur nulle de Python. Pour l’instant nous ne nous occupons que de savoir si le schéma correspond, ce qui peut être sû en regardant simplement la valeur de retour de <code>search()</code>. <code>'M'</code> correspond à cette expression régulière car le premier <code>M</code> optionnel est obtenu, et que les deux <code>M</code> suivants sont ignorés.
<li><code>'MM'</code> correspond car les deux premiers caractères <code>M</code> sont trouvés, et que le dernier <code>M</code> est ignoré.
<li><code>'MMM'</code> correspond car tous les caractères <code>M</code> sont trouvés.
<li><code>'MMMM'</code> ne correspond pas. Les trois caractères <code>M</code> correspondent, mais l’expression rationnelle insiste pour que la chaine s’arrête immédiatement (à cause du caractère <code>$</code>), mais au lieu de cela, elle trouve un caractère <code>M</code>. Donc <code>search()</code> retourne <code>None</code>.
<li>Il est intéressant de noter que la chaine vide correspond également à l’expresion rationnelle, puisque tous les caractères <code>M</code> sont optionnels.
</ol>
<h3 id=hundreds>Vérifier Les Centaines</h3>
<aside>? rend un schéma optionnel.</aside>
<p>Les centaines sont plus difficiles à gérer que les milliers, car il y a plusieurs façons incompatibles de s’en servir, en dépendant de la valeur.
<ul>
<li><code>100 = C</code>
<li><code>200 = CC</code>
<li><code>300 = CCC</code>
<li><code>400 = CD</code>
<li><code>500 = D</code>
<li><code>600 = DC</code>
<li><code>700 = DCC</code>
<li><code>800 = DCCC</code>
<li><code>900 = CM</code>
</ul>
<p>Il y a donc quatre schémas possibles&nbsp;:
<ul>
<li><code>CM</code>
<li><code>CD</code>
<li>De zéro à trois caractères <code>C</code> (zéro si le chiffre des dizaines est 0)
<li><code>D</code>, suivi par au plus trois caractères <code>C</code>
</ul>
<p>Les deux derniers schémas peuvent être combinés&nbsp;:
<ul>
<li>un <code>D</code> optionnel, suivi par au plus trois caractères <code>C</code>
</ul>
<p>Cet exemple montre comment valider les centaines d’un nombre romain.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)$'</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCM')</kbd>             <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 01070390></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MD')</kbd>              <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 01073A50></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMCCC')</kbd>          <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 010748A8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMC')</kbd>            <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>                <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 01071D98></samp></pre>
<ol>
<li>Ce schéma commence de la même façon que le précédent, s’assurant qu’il est au début de la chaine (<code>^</code>), puis les milliers (<code>M?M?M?</code>). Ensuite, on ajoute, entre parenthèses, qui définissent un ensemble de trois schémas mutuellement incompatibles, séparés par des barres verticales&nbsp;: <code>CM</code>, <code>CD</code>, et <code>D?C?C?C?</code> (qui est un <code>D</code> optionnel suivi d’au plus trois caractères <code>C</code>). Le parseur d’expressions régulières vérifiera chacun de ces trois schémas dans l’ordre (de gauche à droite), prendra le premier qui correspondra, et ignorera le reste.
<li><code>'MCM'</code> correspond car le premier <code>M</code> est détecté, les deux caractères <code>M</code> suivants sont ignorés, et le <code>CM</code> correspond (donc les schémas <code>CD</code> et <code>D?C?C?C?</code> ne sont même pas testés). <code>MCM</code> est la représentation de <code>1900</code> en nombres romains.
<li><code>'MD'</code> correspond car le premier <code>M</code> est détecté, les deux <code>M</code> suivants sont ignorés, et <code>D</code> correspond au schéma <code>D?C?C?C?</code> (chacun des trois caractères <code>C</code> est optionnel et est ignoré). <code>MD</code> est la représentation romaine de <code>1500</code>.
<li><code>'MMMCCC'</code> correspond car les trois caractères <code>M</code> sont détectés, et le schéma <code>D?C?C?C?</code> accepte <code>CCC</code> (le <code>D</code> est optionnel et est ignoré). <code>MMMCCC</code> est la représentation romaine de <code>3300</code>.
<li><code>'MCMC'</code> ne correspond pas. Le premier <code>M</code> va, les deux <code>M</code> suivants sont ignorés, et <code>CM</code> est accepté, mais le <code>$</code> refuse d’être validé car vous n’êtes pas à la fin de la chaine (il reste un caractère <code>C</code>). Le <code>C</code> ne correspond <em>pas</em> au schéma <code>D?C?C?C?</code>, car les schémas <code>CM</code> mutuellement incompatibles correspondent déjà à quelque chose.
<li>Il est intéressant de noter que la chaine vide correspond toujours à ce schéma, car tous les caractères <code>M</code> sont optionnels et ignorés, et la chaine vide correspond au schéma <code>D?C?C?C?</code> où tous les caractères sont optionnels et ignorés.
</ol>
<p>Wow ! Vous voyez à quelle vitesse les expressions rationnelles peuvent devenir sales&nbsp;? Et vous n’avez traité que les milliers et les centaines dans les nombres romains. Mais une fois que vous avez fait ça, les dizaines et les unités sont faciles car elles suivent exactement le même schéma. Mais regardons notre schéma d’une autre façon.
<p class=a>&#x2042;

<h2 id=nmsyntax>Utiliser La Syntaxe <code>{n,m}</code></h2>
<aside>{1,4} correspond à un nombre d’occurences d’un schéma compris entre 1 et 4.</aside>
<p>Dans la section précédente, nous avions vu un schéma où le même caractère pouvait être répété jusqu’à trois fois. Voici une autre façon de l’exprimer dans des expressions régulières, ce que certaines personnes trouvent plus lisible. D’abord, regardons à la méthode que nous avons utilisée dans l’exemple précédent.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ceci valide le début de la chaine, puis le premier <code>M</code> optionnel, mais pas les deux <code>M</code> suivants (mais ça passe car ils sont optionnels), et la fin de la chaine.
<li>Ceci valide le début de la chaine, puis les deux premiers <code>M</code> optionnels, mais pas le <code>M</code> suivant (mais ça passe car il est optionnel), et la fin de la chaine.
<li>Ceci valide le début de la chaine, puis les trois caractères <code>M</code> optionnels, et la fin de la chaine.
<li>Ceci valide le début de la chaine, puis les trois caractères <code>M</code> optionnels , mais ne correspond pas à la fin de la chaine (car il y a des <code>M</code> qui ne correspondent pas), donc le schéma ne valide pas et retourne <code>None</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<samp>>>> </samp></pre>
<ol>
<li>Ce schéma dit « Détecte le débit de la chaine, puis entre zéro et trois caractères <code>M</code>, puis la fin de la chaine ». Le 0 et le 3 peuvent être n’importe quel nombre&nbsp;; si vous voulez détecter au moins 1 mais pas plus de trois caractères <code>M</code>, vous pouvez simplement dire <code>M{1,3}</code>.
<li>Ceci détecte le début de la chaine, puis un <code>M</code> sur les trois possibles, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis deux <code>M</code> sur les trois possibles, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis trois <code>M</code> sur les trois possibles, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis trois <code>M</code> sur les trois possibles avant la fin de la chaine. Mais il y en a quatre, donc le schéma ne valide pas et retourner <code>None</code>.
</ol>
<h3 id=tensandones>Vérifier Les Dizaines Et Les Unités</h3>
<p>Maintenant, étendons notre expression rationnelle pour couvrir les dizaines et les unités. Cet exemple montrer comment vérifier les dizaines.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMXL')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCML')</kbd>      <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLX')</kbd>     <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXX')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXX')</kbd>  <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis <code>XL</code>, puis la fin de la chaine. Souvenez-vous, la syntaxe <code>(A|B|C)</code> correspond à « exactement A, B, <em>ou</em> (exclusif) C ». Vous testez <code>XL</code>, donc vous ignorez les choix <code>XC</code> et <code>L?X?X?X?</code>, puis passez à la fin de la chaine. <code>MCMXL</code> est la représentation romaine de <code>1940</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis <code>L?X?X?X?</code>. Le schéma <code>L?X?X?X?</code> détecte le <code>L</code> et passe à la suite en sautant les trois caractères <code>X</code> optionnels. Puis vous passez à la fin de la chaine. <code>MCML</code> est la représentation romaine de <code>1950</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis le <code>L</code> optionnel et le <code>X</code> optionnel, saute les deux <code>X</code> suivants optionnels, puis la fin de la chaine. <code>MCMLX</code> est la représentation romaine de <code>1960</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis le <code>L</code> optionnel et les trois <code>X</code> optionnels, puis la fin de la chaine. <code>MCMLXXX</code> est la représentation romaine de <code>1980</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis le <code>L</code> optionnel et les trois <code>X</code> optionnels, puis <em>ne valide pas</em> car il y a encore un <code>X</code> non validé avant la fin de la chaine. Donc tout le schéma échoue à valider et retourne <code>None</code>. <code>MCMLXXXX</code> n’est pas un nombre romaine valide.
</ol>
<aside>(A|B) correspond soit à A soit à B, mais pas aux deux.</aside>
<p>L’expression pour les unités suit le même schéma. Je vous épargne les détails et vous donne tout de suite le résultat final.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</kbd>
</pre><p>Donc, à quoi cela ressemble-t-il si on utilise la syntaxe alternativee <code>{n,m}</code>&nbsp;? Cet exemple montre la nouvelle syntaxe.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MDLV')</kbd>              <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMDCLXVI')</kbd>          <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII')</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'I')</kbd>                 <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp></pre>
<ol>
<li>Ceci correspond au début de la chaine, puis un des trois caractères <code>M</code> possibles, puis <code>D?C{0,3}</code>. À cela correspond de <code>D</code> optionnel et aucun des trois caractères <code>C</code> possibles. En continuant, il détecte <code>L?X{0,3}</code> en correspondance avec <code>L</code> and et aucun des trois caractères <code>X</code> possibles. Puis il fait correspondre <code>V?I{0,3}</code> au <code>V</code> optionnel et à aucun des trois <code>I</code> possibles, et enfin à la fin de la chaine. <code>MDLV</code> est la représentation romaine de <code>1555</code>.
<li>Ceci correspond au début de la chaine, puis deux des trois <code>M</code> possibles, puis <code>D?C{0,3}</code> à <code>D</code> et un des trois <code>C</code> possibles&nbsp;; <code>L?X{0,3}</code> à <code>L</code> et un des trois <code>X</code> possibles&nbsp;; puis <code>V?I{0,3}</code> à <code>V</code> et un des trois <code>I</code> possibles&nbsp;; et enfin la fin de la chaine. <code>MMDCLXVI</code> est la représentation romaine de <code>2666</code>.
<li>Ceci correspond au début de la chaine, puis les trois caractères <code>M</code> autorisés, puis <code>D?C{0,3}</code> détectant <code>D</code> et les trois <code>C</code>&nbsp;; puis <code>L?X{0,3}</code> détectant <code>L</code> et les trois <code>X</code>&nbsp;; puis <code>V?I{0,3}</code> avec <code>V</code> et les trois <code>I</code>&nbsp;; puis la fin de la chaine. <code>MMMDCCCLXXXVIII</code> est la représentation romaine de <code>3888</code>, et est le plus grand nombre romain que vous puissiez écrire sans la syntaxe étendue.
<li>Regardez attentivement. (Je me sens comme un magicien. «&nbsp;Regardez attentivement, les enfants, je vais sortir un lapin de mon chapeau.&nbsp;») Ceci correspond au début de la chaine, puis aucun des trois <code>M</code>, puis <code>D?C{0,3}</code> en sautant le <code>D</code> optionnel et ne détectant aucun des trois <code>C</code> possibles, puis fait correspondre <code>L?X{0,3}</code> en sautant le <code>L</code> optionnel et aucun des trois <code>X</code> possibles, puis <code>V?I{0,3}</code> en sautant le <code>V</code> optionnel, et un des trois <code>I</code> possibles. Et enfin la fin de la chaine. Wow.
</ol>
<p>Si vous avez suivi et compris ceci du premier coup, vous vous en sortez mieux que moi lors de mon apprentissage. Maintenant imaginez que vous essayez de comprendre les expressions rationnelles de quelqu’un d’autre, au milieu d’une fonction critique d’un grod programme. Ou imaginez que vous revenez à une de vos propres expressions rationnelles quelques mois plus tard. Ça m’est déjà arrivé, et ce n’est pas joli à voir.
<p>Maintenant, explorons une syntaxe alternative qui peut vous aider à garder vos expressions compréhensibles.
<p class=a>&#x2042;

<h2 id=verbosere>Expressions rationnelles verbeuses</h2>
<p>Jusqu’à présent nous n’avons utilisé que ce que j’appelle des expressions régulières compactes. Comme vous pouvez le constater, elles sont difficiles à dire, et même si vous devinez ce que fait l’une d’entre elles, il n’y a aucune garantie que vous le compreniez toujours six mois plus tard. Ce dont vous avez besoin est de la documentation «&nbsp;en ligne&nbsp;» (c’est-à-dire sur la ligne-même de l’expression).
<p>Python vous permet de faire ce qu’on appelle des <i>expressions rationnelles verbeuses</i>. Une expression rationnelle verbeuse est différente d’une expression régulière compacte sur deux points&nbsp;:
<ul>
<li>Les espaces blanches sont ignorées. Les espaces, tabulations, et retours chariot ne snt pas considérés comme des espaces, tabulations, et retours chariot. Ils ne sont juste pas pris en compte. (Si vous voulez qu’ils le soient, vous devez les échapper en ajoutant un backslash juste avant.)
<li>Les commenaires sont ignorés. Un commentaire dans une expression rationnelle verbeuse est comme un commentaire Python&nbsp;: il commence avec un caractère <code>#</code> et va jusqu’à la fin de la ligne. Dans ce cas, c’est un commentaire dans une chaine multilignre plutôt que dans le code source, mais ils fonctionnent de la même façon.
</ul>
<p>Ça sera plus clair avec un exemple. Revisitons l’expression rationnelle compacte avec laquelle on avait travaillé jusqu’à présent et rendons-la verbeuse. Cet exemple montre comment.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '''
    ^                   # beginning of string
    M{0,3}              # thousands - 0 to 3 Ms
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),
                        #            or 500-800 (D, followed by 0 to 3 Cs)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),
                        #        or 50-80 (L, followed by 0 to 3 Xs)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),
                        #        or 5-8 (V, followed by 0 to 3 Is)
    $                   # end of string
    '''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M', re.VERBOSE)</kbd>                 <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXIX', re.VERBOSE)</kbd>         <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII', re.VERBOSE)</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>                             <span class=u>&#x2463;</span></a></pre>
<ol>
<li>La chose la plus importante à garder à l’esprit lorsque vous utilisez des expressions rationnelles verbeuses est que vous devez passer un paramètre supplémentaire lorsque vous les utilisez&nbsp;: <code>re.VERBOSE</code>, qui est une constante définie dans le module <code>re</code> et qui signale que le schéma doit être traité comme une expression régulière verbeuse. Comme vous pouvez le constater, ce schéma contient pas mal d’espaces blanches (qui sont toutes ignorées), et plusieurs commentaires (qui sont tous ignorés). Une vois que vous ignorez les espaces et les commentaires, c’est exactement la même expression rationnelle que nous avons vue dans la section précédente, mais elle est beaucoup plus lisible.
<li>Ceci détecte le début de la chaine, puis à un des trois <code>M</code> possibles, puis <code>CM</code>, puis <code>L</code> puis les trois <code>X</code> possibles, puis <code>IX</code>, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis les trois <code>M</code> possibles, puis <code>D</code> puis les trois <code>C</code> possibles, puis <code>L</code> puis les trois <code>X</code> possibles, puis <code>V</code> puis les trois <code>I</code> possibles, puis la fin de la chaine.
<li>Ceci ne correspond pas. Pourquoi&nbsp;? Parce que nous n’avons pas le drapeau <code>re.VERBOSE</code>, donc la fonction <code>re.search</code> traite le schéma comme une expression rationnelle compacte, avec des espaces blanches significatives et des dièses littéraux Python ne peut pas détecter automatiquement si une expression régulière est verbeuse ou non. Python assume que toute expression régulière est compacte à moins que vous n’indiquiez explicitement qu’elle est verbeuse.
</ol>
<p class=a>&#x2042;

<h2 id=phonenumbers>Étude De Cas&nbsp;: Parser Des Numéros De Téléphone Américains</h2>
<aside>\d correspond à n’importe quel chiffre (0&ndash;9). \D correspond à n’importe quoi sauf un chiffre.</aside>
<p>Donc, jusqu’à présent vous vous êtes concentré-e sur la correspondance de schémas entiers. Soit le schéma correspondait, soit il ne correspondait pas. Mais les expressions rationnelles sont bien plus puissantes que ça. Quand une expression rationnelle correspond <em>effectivement</em>, vous pouvez en extraire des morceaux spécifiques. Vous pouvez savoir ce qui a été détecté, et où.
<p>Cet exemple vient d’un autre problème réel que j’ai rencontré, encore une fois dans mon travail. Le problème&nbsp;: parser un numéro de téléphone américain. La demande était d’entrer un numéro de n’importe quelle forme, mais les différents champs (code de zone, tronc, nombre, et optionnellement une extension) devaient être stockés séparément dans la base de données de l’entreprise. J’ai parcouru le Web et ai trouvé de nombreux exemples d’expressions régulières faisant cela, mais aucun n’était assez permissive.
<p>Voici les numéros de téléphone que je devais accepter&nbsp;:
<ul>
<li><code>800-555-1212</code>
<li><code>800 555 1212</code>
<li><code>800.555.1212</code>
<li><code>(800) 555-1212</code>
<li><code>1-800-555-1212</code>
<li><code>800-555-1212-1234</code>
<li><code>800-555-1212x1234</code>
<li><code>800-555-1212 ext. 1234</code>
<li><code>work 1-(800) 555.1212 #1234</code>
</ul>
<p>Quelle variété&nbsp;! Dans chacun de ces cas, le devais savoir que le code de zone était <code>800</code>, le tronc <code>555</code>, et le reste du numéro était <code>1212</code>. Pour ceux avec une extension, je devais savoir que cette extension était <code>1234</code>.
<p>Travaillons à développer une solution pour parser des numéros de téléphone. Cet exemple montre la première étape.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234')</kbd>                 <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'NoneType' object has no attribute 'groups'</samp></pre>
<ol>
<li>Lisez toujours les expressions rationnelles de gauche à droite. Celle-ci détecte le début de la chaine, puis <code>(\d{3})</code>. Qu’est-ce que <code>\d{3}</code>&nbsp;? Eh bien, <code>\d</code> signifie «&nbsp;n’importe quel chiffre&nbsp;» (de 0 à 9). Le <code>{3}</code> signifie «&nbsp;faire correspondre exactement trois fois ce schéma&nbsp;» (ici, trois fois un chiffre)&nbsp;; c’est une variation de la <a href=#nmsyntax>syntaxe <code>{n,m}</code></a> que nous avons vue plus tôt. Mettre tout cela entre parenthèses signifie «&nbsp;détecter exactement trois chiffres, et <em>s’en souvenir en tant que groupe que nous pouvons demander par la suite</em>&nbsp;». Puis détecter un tiret litéral. Puis un autre groupe de trois chiffres. Puis un autre tiret litéral. Puis un autre groupe d’exactement quatre chiffres. Puis la fin de la chaine.
<li>Pour accéder aux groupes que le parseur d’expressions régulières a rencontré lors de son parcourt, utilisez la méthode <code>groups()</code> de l’objet retourné par la méthode <code>search()</code>. Il retourne un n-uplet où n est le nombre de groupes définis dans l’expression rationnelle. DAns ce cas, vous avez défini trois groupes, un avec trois chiffres, un autre avec trois chiffres, et un avec quatre chiffres.
<li>Et cette expression rationnelle n’est pas la réponse finale, car elle refuse les numéros de téléphone avec une extension à la fin. Pour cela, nous allons devoir étendre l’expression rationnelle.
<li>Et c’est pourquoi vous ne devriez jamais enchaine les méthodes <code>search()</code> et <code>groups()</code> dans un code en production. Si la méthode <code>search()</code> refuse la chaine, elle retourne <a href=native-datatypes.html#none><code>None</code></a>, pas un objet de correspondance d’expression rationnelle. Appeler <code>None.groups()</code> lève une exception tout à fait évidente&nbsp;: <code>None</code> n’a pas de méthode <code>groups()</code>. (Bien sûr, c’est beaucoup moins évident lorsque vous obtenez cette exception profondément dans votre code. Oui, je parle d’expérience ici.)
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})-(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>              <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Cette expression rationnelle est presque identique à la précédente. Comme précédemment, vous détectez le débu de la chaine, vous souvenez d’un groupe de trois chiffres, rencontrez un tiret, puis vous souvenez d’un groupe de trois chiffres, puis rencontrez un nouveau tiet, puis vous souvenez d’un groupe de quatre chiffres. Ce qui est nouveau est que vous détectez alors un autre tiret, et vous souvenez d’un groupe de plusieurs chiffres (au moins un), puis la fin de la chaine.
<li>La méthode <code>groups()</code> retourne maintenant un quadruplet, puisque l’expression défini quatre groupes.
<li>Malheureusement, cette expression rationnelle n’est pas la réponse finale non plus, car elle considère que les différentes parties du numéro de téléphne sont séparées par des tirets. Et si elles étaient séparées par des espaces, virgules, ou points&nbsp;? Vous devez trouver une solution plus générale pour détecter les différents types de séparateurs.
<li>Oups&nbsp;! Non seulement cette expression ne fait pas tout ce que l’on veut, mais en plus c’est un retour en arrière car elle ne peut pas correspondre aux numéros de téléphone <em>sans</em> extension. Ce n’est pas du tout ce que nous voulons. Si l’extension est là, nous voulons la connaitre, mais si elle ne l’est pas nous voulons tout de même connaitre les différentes parties du numéro principale.
</ol>
<p>L’exemple suivant montre une expression rationnelle qui gère les séparateurs entre les différentes parties du numéro.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234').groups()</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234')</kbd>              <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Accrochez-vous à votre chapeau. Nous détectons le début de la chaine, puis un groupe de trois chiffres, puis <code>\D+</code>. Qu’est-ce que c’est que ce truc&nbsp;? Eh bien, <code>\D</code> détecte n’importe quel caractère <em>sauf</em> un chiffre, et <code>+</code> signifique «&nbsp;un ou plus&nbsp;». Donc <code>\D+</code> détecte un ou plusieurs caractères qui ne sont pas des chiffres. C’est ce que nous utilisons à la place des tirers litéraux pour détecter différent types de séparateurs.
<li>Utiliser <code>\D+</code> plutôt que <code>-</code> signifique que vous pouvez des détecter des numéros de téléphone dont les parties sont séparées par des espaces plutôt que par des tirets.
<li>Bien sûr, les numéros de téléphones séparés par des tirets marchent toujours.
<li>Malheureusement, ce n’est toujours pas la réponse finale, car on considère qu’il doit toujours y avoir. Et si le numéro de téléphone est entré sans aucun espace ou tiret&nbsp;?
<li>Oups&nbsp;! Ça n’a toujours pas corrigé le problème de nécessiter une extension. Maitenant nous avons deux problèmes, mais vous pouvez toujours la résoudre avec la même technique.
</ol>
<p>L’exemple suivant montre l’expression rationnelle pour gérer les numéros de téléphone <em>sans</em> séparateur.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800.555.1212 x1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 x1234')</kbd>           <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Le seul changement que nous avons fait depuis la dernière étape et de changer tous les <code>+</code> en <code>*</code>. Plutôt que d’avoir <code>\D+</code> entre les parties du numéro de téléphone, nous cherchons maintenant à faire correspondre <code>\D*</code>. Vous vous souvenez que <code>+</code> signifie «&nbsp;un ou plus&nbsp;»&nbsp;? Eh bien, <code>*</code> signifie «&nbsp;zéro ou plus&nbsp;». Maintenant nous sommes capables de parser les numéros de téléphone même s’ils ne contiennent aucun séparateur.
<li>Et voilà que ça marche pour de bon. Pourquoi&nbsp;? On détecte le début de la chaine, puis se souvient de trois chiffres (<code>800</code>), puis aucun caractère non numérique, puis un groupe de trois chiffres (<code>555</code>), puis aucun caractère non numérique, puis un groupe de quatre chiffres (<code>1212</code>), puis aucun caractère non numérique, puis un groupe d’un nombre quelconque de chiffres (<code>1234</code>), puis la fin de la chaine.
<li>D’autres variations marchvent également à présent&nbsp;: des points à la place des tirets, et à la fois un espace et un <code>x</code> avant l’extension.
<li>Finalement, nous avons résolu un autre problème de longue date&nbsp;: les extensions sont à nouveau optionnelles. Si aucune extension n’est trouvée, la méthode <code>groups()</code> retournera toujours un quadruplet, mais le quatrième élément sera seulement une chaine vide.
<li>Je déteste faire l’oiseau de mauvais augure, mais nous n’avons pas encore fini. Quel est le problème ici&nbsp;? Il y a un caractère supplémentaire avant le code de zone, mais l’expression rationnelle considère que le code de zone est la première chose au début d’une chaine. Aucun problème, nous pouvons utiliser la même technique de «&nbsp;zéro caractères non numériques, ou plus&nbsp;» pour sauter les caractères avant le code de zone.
</ol>
<p>L’exemple suivant montre comment gérer les caractères précédent les numéros de téléphone.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 ext. 1234').groups()</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                            <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234')</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>C’est la même que dans l’exemple précédent, à part que maintenant on recherche <code>\D*</code>, zéro caractère non numérique ou plus, avant le premier groupe dont on se souvient (le code de zone). Notez que l’on ne se souvient pas de ces caractères non numériques (ils ne sont pas entre parenthèses). S’il y en a, on ne fait que les ignorer, et on ne commence à retenir  qu’à partir du code de zone, quel que soit l’endroit où il se trouve.
<li>Vous pouvez parser avec succès le numéro de téléphone, même si il y a une parenthèse ouvrante avec le code de zone. (La parenthèse fermante après le code de zone est déjà gérée&nbsp;; elle est traitée comme un séparateur non numérique et correspond que <code>\D*</code> après le premier groupe retenu.)
<li>Seulement une vérification pour s’assurer que l’on n’a pas cassé quelque chose qui marchait auparavant.
<li>C’est là que les expressions rationnelles me donnent envie de me crever les yeux avec un objet pointu. Pourquoi ce numéro ne correspond-t-il pas&nbsp;? Parce qu’il y a un <code>1</code> avant le code de zone, mai on avait considéré que tous les caractères avant le code de zone devaient être non numériques (<code>\D*</code>). Arg.
</ol>
<p>Réfléchissons une seconde. Jusqu’à présent le texte détecté par expressions rationnelles commençait forcément au début de la chaine. Mais comme vous pouvez le constater, il y a une quantité indétermée de choses que nous voulons ignorer, au début de la chaine. Plutôt que d’essayer de le faire correspondre pour le sauter, nous allons utiliser une autre approche&nbsp;: nous n’allons pas explicitement demander le début de la chaine. Cette approche est présente dans l’exemple suivant.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>         <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp></pre>
<ol>
<li>Notez l’absence de <code>^</code> dans cette expression rationnelle. Vous ne recherchez plus le début de la chaine. Il n’y a rien qui dit que vous avez besoin de faire correspondre l’intégralité du texte d’entrée avec l’expression rationnelle. Le moteur d’expression rationnelle fera le gros du travail en essayant de trouver où la chaine en entrée commence à correspondre, et partir de là.
<li>À présent on réussit à parser un numéro de téléphone qui inclut des caractères et un chiffre au début, ainsi que n’importe quel type de séparateur autour de chacune des parties du numéro de téléphone.
<li>Vérification. Ça fonctionne toujours.
<li>Ça aussi.
</ol>
<p>Vous voyez à quel point une expression rationnelle devient rapidement hors de contrôle&nbsp;? Jetez un coup d’œil à n’importe lequel des essais précédents. Pouvez-vous voir la différence entre celui-ci et celui qui le suit&nbsp;?
<p>Alors que vous comprenez encore la réponse finale (et c’est vraiment la réponse finale&nbsp;; si vous avez découvert un cas qu’il ne gère pas, je ne suis pas au courant), écrivons-la de façon verbeuse, avant que vous n’oubliez les choix que nous avons faits.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'''
                # don't match beginning of string, number can start anywhere
    (\d{3})     # area code is 3 digits (e.g. '800')
    \D*         # optional separator is any number of non-digits
    (\d{3})     # trunk is 3 digits (e.g. '555')
    \D*         # optional separator
    (\d{4})     # rest of number is 4 digits (e.g. '1212')
    \D*         # optional separator
    (\d*)       # extension is optional and can be any number of digits
    $           # end of string
    ''', re.VERBOSE)</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp></pre>
<ol>
<li>En oubliant qu’elle a été séparée en plusieurs lignes, c’est exactement la même expression rationnelle que la dernière étape, donc ne soyiez pas surpris-e qu’elle parse les mêmes entrées.
<li>Vérification finale. Ça marche toujours. Nous avons fini.
</ol>
<p class=a>&#x2042;

<h2 id=summary>Résumé</h2>
<p>Ce n’est que la partie immergée de l’iceberg de ce que les expressions rationnelles peuvent faire. En d’autres mots, même si vous êtes déjà complètement paniqué-e par celles-ci maintenant, croyez-moi, vous n’avez encore rien vu.
<p>Vous devriez être familier-ère avec les techniques suivantes&nbsp;:
<ul>
<li><code>^</code> correspond au début de la chaine.
<li><code>$</code> correspond à la fin de la chaine.
<li><code>\b</code> correspond à la frontière d’un mot.
<li><code>\d</code> correspond à n’importe quel chiffre.
<li><code>\D</code> correspond à n’importe quel caractère non numérique.
<li><code>x?</code> correspond à un caractère <code>x</code> optionnel (en d’autres mots, il correspond à <code>x</code> zéro ou une fois).
<li><code>x*</code> correspond à <code>x</code>, au moins zéro fois.
<li><code>x+</code> correspond à <code>x</code>, au moins une fois.
<li><code>x{n,m}</code> correspond à <code>x</code> entre <code>n</code> et <code>m</code> fois (inclus).
<li><code>(a|b|c)</code> correspond à exactement <code>a</code> ou <code>b</code> ou <code>c</code>, mais pas plusieurs à la fois.
<li><code>(x)</code> est en général un <em>groupe retenu</em>. Vous pouvez récupérer la valeur correspondante en utilisant la méthode <code>groups()</code> de l’objet retourné par <code>re.search</code>.
</ul>
<p>Les expressions rationnelles sont extrèmement puissantes, mais elles ne sont pas la solution à tout problème. Vous devez en apprendre suffisament pour savoir que quand elles sont appropriées elles vont résoudre vos problèmes, mais sinon elles vont en poser plus qu’elles ne vont en résoudre.
<p class=v><a href=strings.html rel=prev title='retourner à «&nbsp;Chaines&nbsp;»'><span class=u>&#x261C;</span></a> <a href=generators.html rel=next title='avancer vers «&nbsp;Fermetures &amp; Générateurs&nbsp;»'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
