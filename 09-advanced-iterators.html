---
title: Itérateurs avancés
status: Relecture
permalink: advanced-iterators.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Advanced Iterators - Dive Into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 8}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#advanced-iterators>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Difficulty level: <span class=u title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>Advanced Iterators</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Great fleas have little fleas upon their backs to bite &#8217;em,<br>And little fleas have lesser fleas, and so ad infinitum. <span class=u>&#x275E;</span><br>&mdash; Augustus De Morgan
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Diving In</h2>
<p class=f>Tout comme <a href=regular-expressions.html>les expressions rationnelles</a> mettent <a href=strings.html>les chaines</a> sous stéroïdes, le module <code>itertools</code> met <a href=iterators.html>les iterateurs</a> sous stéroïdes. Mais d’abord, je voudrais vous montrer une énigme classique.

<pre class=nd><code>HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246

H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</code></pre>

<p>Des énigmes comme celle-ci sont appelées <i>cryptarithme</i> ou <i>alphamétique</i>. Les lettres épellées sont des mots réels, mais si vous remplacez chaque lettre par un nombre de <code>0</code> à <code>9</code>, ils deviennent une équation arithmétique. L’astuce est de trouver quelle lettre correspond à chaque chiffre. Toutes les occurences de chaque lettre doivent correspondre au même chiffre, aucun chiffre ne peut être répété, et aucun «&nbsp;mot&nbsp;» ne peut commencer avec le chiffre 0.

<aside>L’alphamétique le plus connu est <code>SEND + MORE = MONEY</code>.</aside>

<p>Dans ce chapitre, nous allons plonger dans un programme Python incroyable écrit à l’origine par Raymond Hettinger. Ce programme résout les alphamétiques <em>en seulement quatorze lignes de code</em>.

<p class=d>[<a href=examples/alphametics.py>télécharger <code>alphametics.py</code></a>]
<pre class=pp><code>import re
import itertools

def solve(puzzle):
    words = re.findall('[A-Z]+', puzzle.upper())
    unique_characters = set(''.join(words))
    assert len(unique_characters) &lt;= 10, 'Too many letters'
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = ''.join(first_letters) + \
        ''.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in '0123456789')
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
        if zero not in guess[:n]:
            equation = puzzle.translate(dict(zip(characters, guess)))
            if eval(equation):
                return equation

if __name__ == '__main__':
    import sys
    for puzzle in sys.argv[1:]:
        print(puzzle)
        solution = solve(puzzle)
        if solution:
            print(solution)</code></pre>

<p>Vous pouvez lancer le programme depuis la ligne de commande. Sous Linux, il ressemblerait à ceci. (Cela peu prendre du temps selon la vitesse de votre ordinateur, et il n’y a pas de barre de progression. Soyez patient-e&nbsp;!)

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "HAWAII + IDAHO + IOWA + OHIO == STATES"</kbd>
<samp>HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "I + LOVE + YOU == DORA"</kbd>
<samp>I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "SEND + MORE == MONEY"</kbd>
<samp>SEND + MORE == MONEY
9567 + 1085 == 10652</samp></pre>

<p class=a>&#x2042;

<h2 id=re-findall>Trouver toutes les occurences d’un motif</h2>

<p>La première chose que fait ce résolveur d’alphamétique est trouver toutes les lettres (A&ndash;Z) dans l’énigme.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[0-9]+', '16 2-by-4s in rows of 8')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['16', '2', '4', '8']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[A-Z]+', 'SEND + MORE == MONEY')</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>['SEND', 'MORE', 'MONEY']</samp></pre>
<ol>
<li>Le module <code>re</code> est l’implémentation de Python des <a href=regular-expressions.html>expressions rationnelles</a>. Il a une fonction habile nommée <code>findall()</code> qui prend une expression rationnelle et une chaine, et trouve toutes les occurences du motif dans la chaine. Dans ce cas, le motif correspond aux séquences de nombres. La fonction <code>findall()</code> retourne une liste de toutes les sous-chaines qui correspondent au motif.
<li>Voici une expression rationnelle qui détecte les séquences de lettres. À nouveau, la valeur de retour est une liste, et chaque élément de la liste est une chaine qui correspondait au motif de l’expression rationnelle.
</ol>

<p>Voici un autre exemple qui stimulera un peu votre cerveau.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>re.findall(' s.*? s', "The sixth sick sheikh's sixth sheep's sick.")</kbd>
<samp class=pp>[' sixth s', " sheikh's s", " sheep's s"]</samp></pre>

<aside>Ceci est le <a href="https://fr.wikipedia.org/wiki/Virelangue">virelangue</a> le plus complexe de l’anglais.</aside>

<p>Surpri-e&nbsp;? L’expression rationnelle cherche une espace, un <code>s</code>, puis la plus petite série possible de n’importe quel caractère (<code>.*?</code>), puis une espace, puis un autre <code>s</code>. Eh bien, en regardant la chaine d’entrée, je trouve cinq correspondances&nbs;:

<ol>
<li><code>The<mark> sixth s</mark>ick sheikh's sixth sheep's sick.</code>
<li><code>The sixth<mark> sick s</mark>heikh's sixth sheep's sick.</code>
<li><code>The sixth sick<mark> sheikh's s</mark>ixth sheep's sick.</code>
<li><code>The sixth sick sheikh's<mark> sixth s</mark>heep's sick.</code>
<li><code>The sixth sick sheikh's sixth<mark> sheep's s</mark>ick.</code>
</ol>

<p>Mais la fonction <code>re.findall()</code> n’en a renvoyé que trois. Plus spécifiquement, elle a renvoyé la première, la troisième, et la cinquième. Pourquoi donc&nbsp;? Parce qu’<em>elle ne retourne pas de sous-chaines qui se recouvrent</em>. La première recouvre la seconde, donc la première est retournée et la seconde est sautée. Puis, la troisième recouvre la seconde, donc la troisième est renvoyée et la quatrième sautée. Enfin, la cinquième est retournée. Trois correspondances, pas cinq.

<p>Ceci n’a rien à voir avec le résolveur d’alphanumérique&nbsp;; je considérais seulement que c’était intéressant.

<p class=a>&#x2042;

<h2 id=unique-items>Trouver les éléments uniques d’une séquence</h2>

<p>Les <a href=native-datatypes.html#sets>ensembles</a> rendent trivial la recherche d’éléments uniques dans une séquence.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['The', 'sixth', 'sick', "sheik's", 'sixth', "sheep's", 'sick']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_list)</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>{'sixth', 'The', "sheep's", 'sick', "sheik's"}</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'EAST IS EAST'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_string)</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>{'A', ' ', 'E', 'I', 'S', 'T'}</samp>
<samp class=p>>>> </samp><kbd class=pp>words = ['SEND', 'MORE', 'MONEY']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>''.join(words)</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>'SENDMOREMONEY'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>set(''.join(words))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>{'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</samp></pre>
<ol>
<li>Étant doné une liste de plusieurs chaines, la fonction <code>set()</code> renvoie un ensemble de chaines uniques de la liste. Cela a du sens si vous y pensez comme une boucle <code>for</code>. Prenez le premier élément de la liste, ajoutez-le dans l’ensemble. Puis le second. Le troisième. Le quatrième. Le cinquième&nbsp;&mdash;&nbsp;euh, attendez, celui-ci était déjà dans l’ensemble, donc il se retrouve listé seulement une fois, parce que les ensembles de Python n’autorisent pas les dupliquats. Puis le sixième. Puis le septième&nbsp;&mdash;&nbsp;à nouveau, un doublon, donc il ne se fait lister qu’une fois. Le résultat final&nbsp;? Tous les élements, uniques, de la liste originale, sans aucun doublon. La liste originale n’a même pas besoin d’être pré-triée.
<li>La même technique fonctionne sur les chaines, puisque les haines ne sont que des suites de caractères.
<li>Étant donné une liste de chaines, <code>''.join(<var>une_liste</var>)</code> concatène toutes les chaines en une seule.
<li>Donc, étant donné une liste de chaine, cette ligne renvoie tous les caractères, uniques, qui apparaissent dans la chaine, sans doublon.
</ol>

<p>Le résolveur d’alphamétique utilise cette technique pour construire l’ensemble de tous les caractères de l’ensemble.

<pre class='nd pp'><code>unique_characters = set(''.join(words))</code></pre>

<p>Cette liste est utilisée par la suite pour assigner des chiffres aux caractères, pendant que le résolveur itère parmi les solutions possibles.

<p class=a>&#x2042;

<h2 id=assert>Faire des assertions</h2>

<p>Comme beaucoup de langages de programmation, Python a une instruction <code>assert</code>. Voici comment il fonctionne.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 2</kbd>                                     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 3</kbd>                                     <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError</samp>
<a><samp class=p>>>> </samp><kbd class=pp>assert 2 + 2 == 5, "Only for very large values of 2"</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError: Only for very large values of 2</samp></pre>
<ol>
<li>L’instruction <code>assert</code> est suivie de n’importe quelle expression Python valide. Dans ce cas, l’expression <code>1 + 1 == 2</code> est évaluée à <code>True</code>, donc l’instruction <code>assert</code> ne fait rien.
<li>Cependant, si Python évalue l’expression à <code>False</code>, l’instruction <code>assert</code> lèvera une <code>AssertionError</code>.
<li>Vous pouvez également inclure un message humainemnt lisible qui sera affiché si l’<code>AssertionError</code> est levée.
</ol>

<p>Ainsi, cette ligne&nbsp;:

<pre class='nd pp'><code>assert len(unique_characters) &lt;= 10, 'Too many letters'</code></pre>

<p>&hellip; est équivalente à ceci&nbsp;:

<pre class='nd pp'><code>if len(unique_characters) > 10:
    raise AssertionError('Too many letters')</code></pre>

<p>Le résolveur d’alphamétique utilise cette instruction <code>assert</code> pour s’arrêter immédiatement si l’énigme contient plus de dix lettres différences. Étant donné que chaque lettre est associée à un chiffre unique, et qu’il y a seulement dix chiffres, une énigme avec plus de dix lettres différentes ne peut pas avoir de solution.

<p class=a>&#x2042;

<h2 id=generator-expressions>Expressions génératrices</h2>

<p>Une expression génératrice est comme une <a href=generators.html>fonction génératrice</a>, sans fonction.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>unique_characters = {'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>gen = (ord(c) for c in unique_characters)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>gen</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;generator object &lt;genexpr> at 0x00BADC10></samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>                                  <span class=u>&#x2462;</span></a>
<samp class=pp>69</samp>
<samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>
<samp class=pp>68</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(ord(c) for c in unique_characters)</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>(69, 68, 77, 79, 78, 83, 82, 89)</samp></pre>
<ol>
<li>Une expression génératrice est comme une fonction anonyme qui prodit des valeurs. L’expression en elle-même ressemble un peu à une <a href=comprehensions.html#listcomprehension>liste par compréhension</a>, à part qu’elle est entourée de parenthèses plutôt que de crochets.
<li>L’expression génératrice renvoie&hellip; un itérateur.
<li>Appeller <code>next(<var>gen</var>)</code> retourne la valeur suivante de l’itérateur.
<li>Si vous le souhaitez, vous pouvez itérer à travers toutes les valeurs possibles et renvoyer un n-uplet, une liste, ou un ensemble, en passant l’expression génératrice à <code>tuple()</code>, <code>list()</code>, ou <code>set()</code>. Dans ces cas, vous n’avez pas besoin d’une paire supplémentaire de parenthèses&nbsp;&mdash;&nbsp;passez tout simplement l’expression <code>ord(c) for c in unique_characters</code> «&nbsp;brute&nbsp;» à la fonction <code>tuple()</code>, et Python devinera qu’il s’agit d’une expression génératrice.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Utiliser une expression génératrice plutôt qu’une liste par compréhension peut économiser à la fois du <abbr>CPU</abbr> et de la <abbr>RAM</abbr>. Si vous voulez construire une liste et la jeter (par exemple la passer à <code>tuple()</code> ou <code>set()</code>), utilisez une expression génératrice à la place&nbsp;!
</blockquote>

<p>Voici une autre façon d’accomplir la même chose, en utilisant une <a href=generators.html>fonction génératrice</a>&nbsp;:

<pre class='nd pp'><code>def ord_map(a_string):
    for c in a_string:
        yield ord(c)

gen = ord_map(unique_characters)</code></pre>

<p>L’expression génératrice est méthode plus compacte mais équivalente.

<p class=a>&#x2042;

<h2 id=permutations>Calculer des permutation&hellip; La Méthode Fénéante&nbsp;!</h2>

<p>Tout d’abord, que sont donc des permutations&nbsp;? Les permutations sont un concept mathématique. (Il y a en fait plusieurs définition, en fonction du type de mathématiques que vous faites. Ici je parle de combinatoire, mais si ça ne vous dit rien, ne paniquez pas. Comme toujours, <a href=https://fr.wikipedia.org/wiki/Permutation>Wikipédia est votre amie</a>.)

<p>L’idée est d’avoir une liste de choses (des nombres, des lettres, des lettres, des ours dansants, &helli;) et trouver toutes les possibilités de les partager en des listes plus petites. Toutes les listes plus petite ont la même taille, qui peuvent être de longueur quelconque entre 1 et le nombre total d’éléments. Oh, et rien ne peut répéter. Les mathématicien-ne-s disent des choses comme trouver les permutations de trois éléments différents en en prenant deux à la fois, ce qui signifie que vous avez une suite de trois éléments et que vous voulez trouver tous les ordres possibles.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>                              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations([1, 2, 3], 2)</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=pp>(1, 2)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(1, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>(2, 1)</samp>                                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(2, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 1)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
<li>Le module <code>itertools</code> a toutes sortes de trucs amusant, y compris une fonction <code>permutations()</code> qui fait le gros du travail de la recherche de permutations.
<li>La fonction <code>permutations()</code> prend une suite (ceci est une liste de trois entiers) et un nombre, qui est le nombre d’élements que vous voulez dans chacun des groupes plus petit. La fonction retourne un itérateur, que vous pouvez utiliser dans une boucle <code>for</code> ou n’importe quel autre chose qui itère. Ici je parcours l’itérateur manuellement pour afficher toutes les valeurs.
<li>La première permutation de <code>[1, 2, 3]</code> en en prenant deux à la fois est <code>(1, 2)</code>.
<li>Notez que les permutations sont ordonnées&nbsp;: <code>(2, 1)</code> est différent de <code>(1, 2)</code>.
<li>C’est tout&nbsp;! Ce sont toutes les permutations de <code>[1, 2, 3]</code> en prenant deux éléments à la fois. Les paires comme <code>(1, 1)</code> et <code>(2, 2)</code> ne s’affichent jamais, car elles contiennent des répétitions et ne sont donc pas des permutations valides. Lorsqu’il n’y a plus de permutation, l’iterateur lève une exception <code>StopIteration</code>.
</ol>

<aside>Le module <code>itertools</code> a toutes sortes de trucs amusants.</aside>

<p>La fonction <code>permutations()</code> ne demande pas nécessairement une liste. Cela peut être n’importe quelle suite&nbsp;&mdash;&nbsp;y compris une chaine.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations('ABC', 3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>('A', 'B', 'C')</samp>                               <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('A', 'C', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'A', 'C')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'C', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'A', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'B', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.permutations('ABC', 3))</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>[('A', 'B', 'C'), ('A', 'C', 'B'),
 ('B', 'A', 'C'), ('B', 'C', 'A'),
 ('C', 'A', 'B'), ('C', 'B', 'A')]</samp></pre>
<ol>
<li>Une chaine est juste une suite de caractères. Dans le cas de la recherche de permutations, la chaine <code>'ABC'</code> est équivalente à la liste <code>['A', 'B', 'C']</code>.
<li>The first permutation of the 3 items <code>['A', 'B', 'C']</code>, taken 3 at a time, is <code>('A', 'B', 'C')</code>. There are five other permutations&nbsp;&mdash;&nbsp;the same three characters in every conceivable order.
<li>Since the <code>permutations()</code> function always returns an iterator, an easy way to debug permutations is to pass that iterator to the built-in <code>list()</code> function to see all the permutations immediately.
</ol>

<p class=a>&#x2042;

<h2 id=more-itertools>Autres Trucs Amusants dans le Module <code>itertools</code></h2>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.product('ABC', '123'))</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>[('A', '1'), ('A', '2'), ('A', '3'), 
 ('B', '1'), ('B', '2'), ('B', '3'), 
 ('C', '1'), ('C', '2'), ('C', '3')]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.combinations('ABC', 2))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('A', 'B'), ('A', 'C'), ('B', 'C')]</samp></pre>
<ol>
<li>La fonction <code>itertools.product()</code> retourne une itérateur contenant le produit cartésien de deux suites.
<li>La fonction <code>itertools.combinations()</code> retourne un itérateur contenant toutes les combinaisons possible de la séquence de longueur donnée. Elle est semblable à la fonction <code>itertools.permutations()</code>, à part qu’elle exclut les combinaisons qui sont des doublons d’autres éléments qui sont dans un ordre différent. Donc, <code>itertools.permutations('ABC', 2)</code> retournera (entre autres) <code>('A', 'B')</code> and <code>('B', 'A')</code>, mais <code>itertools.combinations('ABC', 2)</code> ne retournera pas <code>('B', 'A')</code> puisque c’est un doublon de <code>('A', 'B')</code> dans un ordre différent.
</ol>

<p class=d>[<a href=examples/favorite-people.txt>télécharger <code>favorite-people.txt</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>names = list(open('examples/favorite-people.txt', encoding='utf-8'))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora\n', 'Ethan\n', 'Wesley\n', 'John\n', 'Anne\n',
'Mike\n', 'Chris\n', 'Sarah\n', 'Alex\n', 'Lizzie\n']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = [name.rstrip() for name in names]</kbd>                             <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora', 'Ethan', 'Wesley', 'John', 'Anne',
'Mike', 'Chris', 'Sarah', 'Alex', 'Lizzie']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names)</kbd>                                                 <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Chris', 'Dora', 'Ethan',
'John', 'Lizzie', 'Mike', 'Sarah', 'Wesley']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names, key=len)</kbd>                                        <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Dora', 'John', 'Mike',
'Chris', 'Ethan', 'Sarah', 'Lizzie', 'Wesley']</samp></pre>
<ol>
<li>Cette expression idiomatique retourne une liste des lignes d’un fichier texte.
<li>Malheureusement (pour cet exemple), l’expression <code>list(open(<var>filename</var>))</code> inclut aussi un retour chariot à la fin de chaque ligne. Cette liste par compréhension utilise la méthode <code>rstrip()</code> des chaine pour retirer les espaces blanches à la fin de chaque ligne. (Les chaines ont aussi une méthode <code>lstrip()</code> pour retirer les espaces blanches au début, et <code>strip()</code> qui fait les deux.)
<li>La fonction <code>sorted()</code> prend une liste et la renvoie triée. Par défaut, elle est triée par ordre alphabétique.
<li>Mais la fonction <code>sorted()</code> peut aussi prendre une fonction <em>via</em> le paramètre <var>key</var>, et elle trie en utilisant cette clé. Dans ce cas, la fonction de tri est <code>len()</code>, donc elle trie par <code>len(<var>chaque élément</var>)</code>. Les noms les plus court d’abord, puis les plus longs.
</ol>

<p>Qu’est-ce que cela a à voir avec le module <code>itertools</code>&nbsp;? Je suis heureux que vous vous posiez la question.

<pre class=screen>
&hellip; continuons le shell interactif précédent&hellip;
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>groups</kbd>
<samp class=pp>&lt;itertools.groupby object at 0x00BB20C0></samp>
<samp class=p>>>> </samp><kbd class=pp>list(groups)</kbd>
<samp class=pp>[(4, &lt;itertools._grouper object at 0x00BA8BF0>),
 (5, &lt;itertools._grouper object at 0x00BB4050>),
 (6, &lt;itertools._grouper object at 0x00BB4030>)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>   <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>for name_length, name_iter in groups:</kbd>    <span class=u>&#x2462;</span></a>
<samp class=p>... </samp><kbd class=pp>    print('Noms à {0:d} lettres :'.format(name_length))</kbd>
<samp class=p>... </samp><kbd class=pp>    for name in name_iter:</kbd>
<samp class=p>... </samp><kbd class=pp>        print(name)</kbd>
<samp class=p>... </samp>
<samp>Noms à 4 lettres :
Alex
Anne
Dora
John
Mike
Noms à 5 lettres :
Chris
Ethan
Sarah
Noms à 6 lettres :
Lizzie
Wesley</samp></pre>
<ol>
<li>La fonction <code>itertools.groupby()</code> prend une suite et une fonction clé, et retourne un itérateur qui engendre des paires. Chaque paire contient le résultat de <code>fonction_clef(<var>chaque élément</var>)</code> et un autre itérateur contenant tous les éléments qui partageaient ce résultat de la clé.
<li>Appeler la fonction <code>list()</code> a «&nbsp;épuisé&nbsp;» l’itérateur, c’est-à-dire que vous avez déjà engendré chaque élément dans l’itérateur pour faire une liste. Il n’y a pas de bouton de «&nbsp;remise à zéro&nbsp;» d’un itérateur, vous ne pouvez juste pas le relancer une fois que vous l’avez épuisé. Si vous voulez à nouveau le parcourir (par exemple, dans la boucle <code>for</code> suivante), vous devez à nouveau appeler <code>itertools.groupby()</code> pour créer un nouvel itérateur.
<li>Dans cet exemple, étant donné une liste de noms <em>déjà triés par longueur</em>, <code>itertools.groupby(name, len)</code> mettera tous les noms de quatre lettres dans un itérateur, ceux de cinq lettres dans un autre, etc. La fonction <code>groupby()</code> est complètement générique&nbsp;; elle peut grouper les chaines par première lettre, des nombres par leur nombre de facteur, ou n’importe quelle autre fonction de clé à laquelle vous pouvez penser.
</ol>
<!-- YO DAWG, WE HEARD YOU LIKE LOOPING, SO WE PUT AN ITERATOR IN YOUR ITERATOR SO YOU CAN LOOP WHILE YOU LOOP. -->

<blockquote class=note>
<p><span class=u>&#x261E;</span>La fonction <code>itertools.groupby()</code> ne fonctionne qu’avec une séquence d’entrée qui est déjà triée avec avec la fonction de regroupement. Dans l’exemple précédent, vous avez groupé une liste de noms avec la fonction <code>len()</code>. Cela fonctionnait seulement parce que la liste d’entrée était déjà triée par longueur.
</blockquote>

<p>Regardez-vous attentivement&nbsp;?
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>list(range(0, 3))</kbd>
<samp class=pp>[0, 1, 2]</samp>
<samp class=p>>>> </samp><kbd class=pp>list(range(10, 13))</kbd>
<samp class=pp>[10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.chain(range(0, 3), range(10, 13)))</kbd>        <span class=u>&#x2460;</span></a>
<samp class=pp>[0, 1, 2, 10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 13)))</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 14)))</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.zip_longest(range(0, 3), range(10, 14)))</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12), (None, 13)]</samp></pre>
<ol>
<li>La fonction <code>itertools.chain()</code> prend deux itérateurs et retourne un itérateur qui contient tous les éléments du premier, suivis par tous les éléments du second. (À vrai dire, elle peut prendre n’importe quelle quantité d’itérateur, et les chainer dans l’ordre dans lequel ils ont été passés à la fonction.)
<li>La fonction <code>zip()</code> fait quelque chose d’assez prosaïque qui se trouve être extrêmement utile&nbsp;: elle prend n’importe quel nombre de suites et retourne un itérateur qui onvitnent des n-uplets&nbsp;: d’abord les premiers éléments de chaque séquence, puis les seconds de chacune, puis les troisièmes, etc.
<li>La fonction <code>zip()</code> s’arrête à la fin de la plus courte des séquences. <code>range(10, 14)</code> a quatre éléments (10, 11, 12, et 13), mais <code>range(0, 3)</code> n’en a que trois, donc la fonction <code>zip()</code> retourne un itérateur de trois éléments.
<li>À l’inverse, la fonction <code>itertools.zip_longest()</code> s’arrête à la fin de la <em>plus longue</em> suite, en insérant des valeurs <code>None</code> à la place des éléments après la fin des plus courtes suites.
</ol>

<p id=dict-zip>D’accord, tout cela était très intéressant, mais quel est le rapport avec le résolveur d’alphamétiques&nbsp;? Le voici&nbsp;:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>characters = ('S', 'M', 'E', 'D', 'O', 'N', 'R', 'Y')</kbd>
<samp class=p>>>> </samp><kbd class=pp>guess = ('1', '2', '0', '3', '4', '5', '6', '7')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(zip(characters, guess))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>(('S', '1'), ('M', '2'), ('E', '0'), ('D', '3'),
 ('O', '4'), ('N', '5'), ('R', '6'), ('Y', '7'))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>dict(zip(characters, guess))</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>{'E': '0', 'D': '3', 'M': '2', 'O': '4',
 'N': '5', 'S': '1', 'R': '6', 'Y': '7'}</samp></pre>
<ol>
<li>Étant donné une liste de lettrres et une liste de chiffre (chacun-e représené-e comme une chaine à un caractère), la fonction <code>zip</code> retournera un appariement de lettres et de chiffres, dans l’ordre.
<li>En quoi est-ce génial&nbsp;? Parce que cette structure de données se trouve être exactement celle à passer à la fonction <code>dict()</code> pour créer un dictionnaire qui utilise les lettres comme clé et leur value associée comme valeurs. (Ce n’est pas la seule façon de le faire, bien sûr. Vous pouvez utiliser un <a href=comprehensions.html#dictionarycomprehension>dictionnaire par compréhension</a> pour créer un dictionnaire directement.) Même si la représentation affichée du dictionnaire liste les paires dans un ordre différent (les dictionnaires n’ont par d’«&nbsp;ordre&nbsp;» en eux-mêmes), vous pouvez voir que chaque lettre est associée au chiffre, en se basant sur l’ordre des suites <var>characters</var> et <var>guess</var> originales.
</ol>

<p id=guess>Le résolveur d’alphamétiques utilise cette technique pour créer un dictionnaire qui fait correspondre à chaque lettre un chiffre de la solution, pour chaque solution possible.

<pre class='nd pp'><code>characters = tuple(ord(c) for c in sorted_characters)
digits = tuple(ord(c) for c in '0123456789')
...
for guess in itertools.permutations(digits, len(characters)):
    ...
<mark>    equation = puzzle.translate(dict(zip(characters, guess)))</mark></code></pre>

<p>Mais quelle est cette méthode <code>translate()</code>&nbsp;? Ah, maintenant vous arrivez à la partie amusante.

<p class=a>&#x2042;

<h2 id=string-translate>Une Nouvelle Sorte de Manipulation de Chaine</h2>

<p>Les chaines PYthon ont beaucoup de méthodes. Vous avez découvert certaines d’entre elles dans le chapitre sur <a href=strings.html>Les Chaines</a>&nbsp;: <code>lower()</code>, <code>count()</code>, et <code>format()</code>. Maintenant je voudrais vous faire découvrir une technique de manipulation des chaines puissante mais peu connue&nbsp;: la méthode <code>translate()</code>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = {ord('A'): ord('O')}</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>                         <span class=u>&#x2461;</span></a>
<samp class=pp>{65: 79}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'MARK'.translate(translation_table)</kbd>       <span class=u>&#x2462;</span></a>
<samp class=pp>'MORK'</samp></pre>
<ol>
<li>La traduction commence avec une table de traduction, qui n’est qu’un dictionnaire faisant correspondre un caractère à un autre. À vrai dire, «&nbsp;caractère&nbsp;» est incorrect&nbsp;&mdash;&nbsp;la table de traduction fait en fait correspondre un <em>octet</em> à un autre.
<li>Souvenez-vous, les octets en Python 3 sont des entiers. La fonction <code>ord()</code> retourne la valeur <abbr>ASCII</abbr> d’un caractère, qui est, dans le A&ndash;Z, un octet entre 65 et 90.
<li>Le méthode <code>translate()</code> d’une chaine prend une table de traduction et l’applique à la chaine. C’est-à-dire qu’elle remplace chaque occurence de l’une des clés de la table de traduction par la valeur correspondante. Dans ce cas, «&nbsp;traduisant&nbsp;» <code>MARK</code> en <code>MORK</code>.
</ol>

<aside>Maintenant vous arrivez <em>vraiment</em> à la partie amusante.</aside>

<p>Quel est le rapport avec le résolveur d’alphamétique&nbsp;? À vrai dire, tout.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>characters = tuple(ord(c) for c in 'SMEDONRY')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>characters</kbd>
<samp class=pp>(83, 77, 69, 68, 79, 78, 82, 89)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>guess = tuple(ord(c) for c in '91570682')</kbd>            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>guess</kbd>
<samp class=pp>(57, 49, 53, 55, 48, 54, 56, 50)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = dict(zip(characters, guess))</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>
<samp class=pp>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'SEND + MORE == MONEY'.translate(translation_table)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'9567 + 1085 == 10652'</samp></pre>
<ol>
<li>En utilisant une <a href=#generator-expressions>expression génératrice</a>, nous calculons rapidement les valeurs des octets de chaque caractère dans la chaine. <var>characters</var> est un exemple d’une valeur de <var>sorted_characters</var> dans la fonction <code>alphametics.solve()</code>.
<li>En utilisant une autre expression génératrice, nous calculons rapidement la valeur des octets de chaque chiffre dans cette chaine. Le résultat, <var>guess</var>, est de la forme <a href=#guess>retournée par la fonction <code>itertools.permutations()</code></a> dans la fonction <code>alphametics.solve()</code>.
<li>Cette table de traduction est engendrée en <a href=#dict-zip>zippant <var>characters</var> et <var>guess</var> ensemble</a> et en construisant un dictionnaire à partir de la suite de paires résultante. C’est exactement ce que fait la fonction <code>alphametics.solve()</code> dans la boucle <code>for</code>.
<li>Finalement, nous passons cette table de traduction à la méthode <code>translate()</code> de la chaine originale de l’énigme. Elle convertir chaque lettre de la chaine en le chiffre correspondant (en se basant sur les lettres dans <var>characters</var> et les chiffres dans <var>guess</var>). Le résultat est une expression Python valide, dans une chaine.
</ol>

<p>C’est assez impressionant. Mais que pouvez-vous faire avec une chaine qui se trouve être une expression Python valide&nbsp;?

<p class=a>&#x2042;

<h2 id=eval>Évaluer des Chaines Arbitraires comme des Expressions Python</h2>

<p>C’est la partie finale de notre énigme (ou plutôt, de notre résolveur d’énigme). Après toutes ces manipulations de chaine fantaisistes, nous nous retrouvons avec une chaine de la forme <code>'9567 + 1085 == 10652'</code>. Mais c’est une chaine, et que peut-on faire avec une chaine&nbsp;? La donner <code>eval()</code>, l’outil d’évalutation Python universel.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 2')</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 3')</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('9567 + 1085 == 10652')</kbd>
<samp class=pp>True</samp></pre>

<p>Mais attendez, il y a mieux&nbsp;! La fonction <code>eval()</code> n’est pas limitée aux expressions booléennes. Elle peut traiter <em>n’importe quelle expression</em>, et renvoyer <em>n’importe quel type de données</em>.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('"A" + "B"')</kbd>
<samp class=pp>'AB'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"MARK".translate({65: 79})')</kbd>
<samp class=pp>'MORK'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"AAAAA".count("A")')</kbd>
<samp class=pp>5</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('["*"] * 5')</kbd>
<samp class=pp>['*', '*', '*', '*', '*']</samp></pre>

<p>Mais attendez, ce n’est pas tout&nbsp;!

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5")</kbd>         <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(x, 2)")</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)")</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>L’expression qu’<code>eval()</code> prend peut faie référence à des variables globales définies en-dehors d’<code>eval()</code>. Si elle est appelée dans une fonction, elle peut auss faire référence aux variables locales.
<li>Et aux fonctions.
<li>Et aux modules.
</ol>

<p>Euh… attendez une minute&hellip;

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import subprocess</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('ls ~')")</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>'Desktop         Library         Pictures \
 Documents       Movies          Public   \
 Music           Sites'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('rm /un/fichier/quelconque')")</kbd>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>Le module <code>subprocess</code> vous permet d’exécuter n’importe quelle commande shell et avoir le résultat sous forme de chaine Python.
<li>Des commandes shell arbitraires peuvent avoir des effets permanents.
</ol>

<p>C’est même pire que ça, puisqu’il y a une fonction globale <code>__import__()</code> qui prend un nom de module sous forme de chaine de caractère, l’importe, et retourne une référence vers celui-ci. Combiné à la puissance d’<code>eval()</code>, vous pouvez construire une seule expression qui efface tous vos fichiers&nbsp;:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /un/fichier/quelconque')")</kbd>  <span class=u>&#x2460;</span></a></pre>
<ol>
<li>Maintenant, imaginez la sortie de <code>'rm -rf ~'</code>. En fait, il n’y aurait pas du tout de sortie, mais vous n’auriez plus du tout de fichier restant non plus.
</ol>

<p class=xxxl>eval() est le MAL

<p>Bon, en fait, ce qui est mal est d’évaluer des expressions arbitraires à partir de sources qui ne son pas de confiance. Vous devez utiliser <code>eval()</code> uniquement à partir d’une source sure. Bien sûr, le truc est de déterminer ce qui est «&nbsp;de confiance&nbsp;». Mais il y a une chose dont je suis sûr&nbsp;: vous <em>NE DEVEZ PAS</em> prendre ce résolveur d’alphamétique et le mettre sur internetcomme un petit service web amusant. Ne faites pas l’erreur de pensez «&nbsp;Bah, cette fonction fait plein de manipulations de chaine avant de donner une chaine à évaluer&nbsp;; <em>je ne trouve pas</em> de moyen pour exploiter ceci.&nbsp;» Quelqu’un <b>VA</b> trouver un moyen d’insérer un vilain code exécutable qui passera à travers les manipulations de chaine (<a href=http://www.securityfocus.com/blogs/746>des choses plus bizarres sont déjà arrivées</a> (en anglais)), et vous pourriez dire adieu à votre serveur.

<p>Mais il y a sans doute un moyen d’évaluer des expressions surement, non&nbsp;? Mettre <code>eval()</code> dans une boite où elle ne peut pas accéder ou faire du mal au monde extérieur&nbsp;? Eh bien, oui et non.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {}, {})</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {"x": x}, {})</kbd>         <span class=u>&#x2461;</span></a>
<samp class=p>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)", {"x": x}, {})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'math' is not defined</samp></pre>
<ol>
<li>Les deuxième et troisième paramètres passés à la fonction <code>eval()</code> font office d’espace de nom global et local pour évaluer l’expression. Dans ce cas, ils sont tous les deux vides, ce qui signifique que quand la chaine <code>"x * 5"</code> est évaluée, il n’y a pas de référence à <var>x</var> dans les espaces de nom global et local, donc <code>eval()</code> lève une exception.
<li>Vous pouvez choisir d’inclure des valeurs spécifique dans l’espace de nom global en les listant individuellement. Puis ces variables&nbsp;&mdash;&nbsp;et seulement celles-ci&nbsp;&mdash;&nbsp;seront disponibles pendant toute l’évaluation.
<li>Même si vous avez importé le module <code>math</code>, vous ne l’avez pas inclus dans l’espace de nom passé à la fonction<code>eval()</code>, donc l’évaluation a échoué.
</ol>

<p>Youpi, c’était facile. Faisons un service web d’alphamétiques maintenant&nbsp;!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(5, 2)", {}, {})</kbd>                   <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)", {}, {})</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
    <li>Même si vous avez passé des dictionnaires vides pour les espaces de nom global et local, toutes les fonctions fournies directement par Python sont encore disponible pendant l’évalutation. Donc <code>pow(5, 2) marche, parce que <code>5</code> et <code>2</code> sont des littéraux et <code>pow()</code> est une fonction fournie directement.
<li>Malheureusement (et si vous ne voyez pas en quoi c’est malheureux, continuez à lire), la fonction <code>__import__()</code> est aussi une fonction disponible directement, donc elle marche aussi.
</ol>

<p>Eh oui, cela signifique que vous pouvez encore faire des choses sales, même en définissant explicitement les espaces de nom global et local à des dictonnaires vides en appelant <code>eval()</code>&nbsp;:

<pre class='nd screen'><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /un/fichier/quelconque')", {}, {})</kbd></pre>

<p>Oups. Je suis heureux de ne pas avoir fait ce service d’alphamétiques. Y a-t-il une manière <em>quelconque</em> d’utilise <code>eval()</code> de façon sure&nbsp;? Eh bien, oui et non.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm -rf /')",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp></pre>
<ol>
    <li>Pour évaluer des expressions qui ne sont pas de confiance de façon sure, vous devez définir un espace de nom global qui fait corresponde <code>None</code> (la valeur nulle de Python) à <code>"__builtins__"</code>. En interne, les fonctions accessibles directement, dites «&nbsp;built-in&nbsp;» sont contenues par un pseudo-module nommé <code>"__builtins__"</code>. Ce pseudo-module (<i>ie.</i> ensemble de fonctions «&nbsp;built-in&nbsp;») est mis à la disposition des expressions évaluées, à moins que vous ne changiez explicitement ce comportement, ce qu’on appelle «&nbsp;le surcharger&nbsp;».
<li>Assurez-vous d’avoir d’avoir surchargé <code>__builtins__</code>. Pas <code>__builtin__</code>, ni <code>__built-ins__</code>, ni une autre variation qui semblerait marcher parfaitement, mais vous exposerait à des risques catastrophiques.
</ol>

<p>Donc <code>eval()</code> est sure maintenant&nbsp;? Eh bien, oui et non.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("2 ** 2147483647",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
</pre>
<ol>
<li>Même sans accès à <code>__builtins__</code>, vous pouvez toujours lancer une attaque par déni de service. Par exemple, élever <code>2</code> à la puissance <code>2147483647</code> va faire monter l’utilisation du <abbr>CPU</abbr> de votre serveur à 100% pendant quelques temps. (Si vous voulez essayer ceci dans le shell interactif, appuyez sur <kbd>Ctrl-C</kbd> quelques fois pour en sortir.) Techniquement, cette expression <em>va</em> renvoyer une valeur un jour, mais entre temps, votre serveur travaillera beaucoup pour ne rien fait.
</ol>

<p>Au final, il <em>est</em> possible d’évaluer des expressions Python qui ne soient pas de confiance sans trop de risque, pour certaines définitions de «&nbsp;risque&nbsp;» qui ne sont pas si terribles en réalité. C’est correct si c’est juste pour jouer avec, et si vous lui passez uniquement une entrée de confiance. Mais n’importe quoi d’autre n’est que tenter le diable.

<p class=a>&#x2042;

<h2 id=alphametics-finale>Assembler le Tout</h2>

<p>En résumé&nbsp;: ce programme résout les énigmes alphamétiques par force brute, c’est-à-dire en parcourant exhaustivement toutes les combinaisons possibles. Pour le faire, il&hellip;

<ol>
<li><a href=#re-findall>Trouve toutes les lettres dans l’énigme</a> avec la fonction <code>re.findall()</code>
<li><a href=#unique-items>Trouve toutes les <em>différentes</em> lettres dans l’énigme</a> avec des ensembles et la fonction <code>set()</code>
<li><a href=#assert>Vérifie qu’il y a au plus dix lettres différentes</a> (signifiant que l’énigme est clairement irrésoluble) avec une instruction <code>assert</code>
<li><a href=#generator-objects>Convertit chaque lettre en son équivalent ASCII</a> avec une expression génératrice
<li><a href=#permutations>Calcule toutes les solutions possibles</a> avec la fonction <code>itertools.permutations()</code>
<li><a href=#string-translate>Convertit chaque solution en une expression Python</a> avec la méthode de chaine <code>translate()</code>
<li><a href=#eval>Teste chaque solution possible en évaluant l’expression Python</a> avec la fonction <code>eval()</code>
<li>Retourne la première solution évaluée à <code>True</code>
</ol>

<p>&hellip;en seulement quatorze lignes de code.

<p class=a>&#x2042;

<h2 id=furtherreading>Aller plus loin</h2>

<ul>
<li><a href=http://docs.python.org/3.1/library/itertools.html>Le module<code>itertools</code></a>
<li><a href=http://www.doughellmann.com/PyMOTW/itertools/><code>itertools</code>&nbsp;&mdash;&nbsp;Iterator functions for efficient looping</a>
<li><a href=http://blip.tv/file/1947373/>Watch Raymond Hettinger&#8217;s &#8220;Easy AI with Python&#8221; talk</a> at PyCon 2009
<li><a href=http://code.activestate.com/recipes/576615/>Recipe 576615: Alphametics solver</a>, Raymond Hettinger&#8217;s original alphametics solver for Python 2
<li><a href=http://code.activestate.com/recipes/users/178123/>More of Raymond Hettinger&#8217;s recipes</a> in the ActiveState Code repository
<li><a href=http://en.wikipedia.org/wiki/Verbal_arithmetic>Alphametics on Wikipedia</a>
<li><a href=http://www.tkcs-collins.com/truman/alphamet/index.shtml>Alphametics Index</a>, including <a href=http://www.tkcs-collins.com/truman/alphamet/alphamet.shtml>lots of puzzles</a> and <a href=http://www.tkcs-collins.com/truman/alphamet/alpha_gen.shtml>a generator to make your own</a>
</ul>

<p>Merci beaucoup à Raymond Hettinger pour avoir accepté de changer la licence de son code pour que je puisse le porter à Python 3 et l’utiliser comme base pour ce chapitre.

<p class=v><a href=iterators.html rel=prev title='retour à «&nbsp;Classes &amp; Itérateurs&nbsp;»'><span class=u>&#x261C;</span></a> <a href=unit-testing.html rel=next title='Continuer vers «&nbsp;Tests Unitaires&nbsp;»'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
