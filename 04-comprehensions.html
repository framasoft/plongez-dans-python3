---
title: En compréhension
status: En cours
permalink: comprehensions.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>En compréhension - Plongez dans Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 3}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>Vous êtes ici&nbsp;: <a href=index.html>Index</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#comprehensions>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficulté&nbsp;: <span class=u title=beginner>&#x2666;&#x2666;&#x2662;&#x2662;&#x2662;</span>
<h1>En compréhension</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Notre imagination est étirée à l’extrême, non pas, comme dans la fiction, à imaginer des choses qui n’existent pas vraiment, mais seulement à comprendre ces choses qui sont là. <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Richard_Feynman>Richard Feynman</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Plongée</h2>
<p class=f>Tout langage de programmation a cette fonctionnalité, une chose compliquée intentionellement rendue simple. Si vous venez d’un autre langage, vous pourriez facilement la manquer, car votre ancien langage ne la rendait pas simple (parce qu’il était occupé à rendre quelque chose d’autre simple à la place). Ce chapitre vous apprendra à utiliser les listes par compréhension, les dictionnaires par compréhension, et les ensembles par compréhension&nbsp;: ces trois concepts sont centrés autour d’une technique très puissante. Mais d’abord, je vais faire un détour par deux modules qui vous aideront à naviguer à travers votre système de fichiers.

<p class=a>&#x2042;

<h2 id=os>Travailler Avec Des Fichiers Et Des Répertoires.</h2>

<p>Python 3 est fourni avec un module appelé <code>os</code>, ce qui signifie «&nbsp;système d’exploitation&nbsp;». Le <a href=http://docs.python.org/3.1/library/os.html>module <code>os</code></a> contient une pléthore de fonctions pour obtenir des informations sur&nbsp;&mdash;&nbsp;et dans certains cas pour manipuler&nbsp;&mdash;&nbsp;les répertoires et fichiers locaux, les processus, et les variables d’environnement. Python fait de son mieux pour offrir une <abbr>API</abbr> unifiée pour <a href=installing-python.html>tous les systèmes d’exploitation supportés</a> de façon à ce que vos programmes puissent tourner sur n’importe quel ordinateur avec le moins de code spécifique à une plateforme possible.

<h3 id=getcwd>Le Répertoire De Travail Actuel</h3>

<p>Lorsque vous commencez à vous familiariser avec Python, vous passez beaucoup de temps dans <a href=installing-python.html#idle>le Shell Python</a>. Au cours de ce livre, vous verrez des exemples qui sont présentés de cette façon&nbsp;:

<ol>
<li>Import d’un des modules du répertoire <a href=examples/><code>examples</code></a>
<li>Appel d’une fonction de ce module
<li>Explication du résultat
</ol>

<aside>Il y a toujours un répertoire de travail.</aside>

<p>Si vous ne connaissez pas le répertoire de travail, l’étape 1 va probablement échouer avec une <code>ImportError</code>. Pourquoi&nbsp;? Parce que Python recherchera le module d’exemple dans <a href=your-first-python-program.html#importsearchpath>le chemin de recherche d’import</a>, mais ne le trouvera pas car le dossier <code>examples</code> n’est pas l’un des répertoires du chemin de recherche. Pour régler ce problème, vous avez deux possibilités&nbsp;:

<ol>
<li>Ajouter le dossier <code>examples</code> au chemin de recherche d’import
<li>Changer le répertoire de travail actuel pour être dans le dossier <code>examples</code>
</ol>

<p>Le répertoire de travail courant est une propriété invisible que Python conserve en mémoire en permanence. Il y a toujours un répertoire de travail courant, que vous soyiez dans le Shell Python, que vous exécutiez votre script depuis la ligne de commande ou en temps que script CGI quelque part sur un serveur web.

<p>Le module <code>os</code> contient deux fonctions pour travailler avec le répertoire courant.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import os</kbd>                                            <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                                   <span class=u>&#x2461;</span></a>
<samp>C:\Python31</samp>
<a><samp class=p>>>> </samp><kbd class=pp>os.chdir('/Users/pilgrim/diveintopython3/examples')</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                                   <span class=u>&#x2463;</span></a>
<samp>C:\Users\pilgrim\diveintopython3\examples</samp></pre>
<ol>
<li>Le module <code>os</code> est fourni avec Python&nbsp;: vous pouvez l’importer de n’importe où, n’importe quand.
<li>Utilisez la fonction <code>os.getcwd()</code> pour obtenir le répertoire d’exécution. Quand vous utilisez le Shell Python graphique, le répertoire de travail initial est votre répertoire utilisateur. Sous Windows, c’est l’endroit où vous avez installé Python, le répertoire par défaut étant <code>c:\Python31</code>. Si vous lancez le Shell Python depuis la ligne de commande, le répertoire de travail initial sera le répertoire d’où vous avez exécuté <code>python3</code>.
<li>Utilisez la fonction <code>os.chdir()</code> pour changer le répertoire de travail courant.
<li>Quand j’ai appellé la fonction <code>os.chdir()</code>, j’ai utilisé un nom de chemin tels que ceux utilisés par Linux (slashs, pas de lettre de lecteur) même si je suis sous Windows. C’est un des cas où Python essaye de palier les différences entre les systèmes d’exploitation.
</ol>

<h3 id=ospath>Travailler Avec Les Noms de Fichiers Et De Répertoires</h3>

<p>Puisque nous sommes en train de parler de répertoires, je voulais vous montrer le module <code>os.path</code>. <code>os.path</code> contient des fonctions pour manipuler les noms de fichiers et de répertoires.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join('/Users/pilgrim/diveintopython3/examples/', 'humansize.py'))</kbd>              <span class=u>&#x2460;</span></a>
<samp>/Users/pilgrim/diveintopython3/examples/humansize.py</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join('/Users/pilgrim/diveintopython3/examples', 'humansize.py'))</kbd>               <span class=u>&#x2461;</span></a>
<samp>/Users/pilgrim/diveintopython3/examples\humansize.py</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.expanduser('~'))</kbd>                                                               <span class=u>&#x2462;</span></a>
<samp>c:\Users\pilgrim</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join(os.path.expanduser('~'), 'diveintopython3', 'examples', 'humansize.py'))</kbd>  <span class=u>&#x2463;</span></a>
<samp>c:\Users\pilgrim\diveintopython3\examples\humansize.py</samp></pre>
<ol>
<li>La fonction <code>os.path.join()</code> construit un nom de chemin à partir d’un ou plusieurs noms de chemins partiels. Dans ce cas, il concatène simplement des chaines.
<li>Dans ce cas un peu moins trivial, appeler la fonction <code>os.path.join()</code> ajoutera un backslash supplémentaire à la fin du nom du chemin avant de le joindre au nom du fichier. C’est un backlash plutôt qu’un slash, car j’ai construit cet exemple sur Windows. Si vous le faites sur Linux ou Mac OS X, vous verrez un slash à la place. Ne vous embêtez pas avec les (anti)slashs, utilisez toujours<code>os.path.join()</code> et laissez Python le faire correctement.
<li>La fonction <code>os.path.expanduser()</code> étendra un chemin qui utilise <code>~</code> pour représenter le dossier personnel d’un utilisateur. Ceci fonctionne sur n’importe quelle plateforme sur laquelle les utilisateurs ont un répertoire personnel, y compris Linux, Mac OS X, et Windows. Le chemin retourné n’a pas de slash final, mais la fonction <code>os.path.join()</code> n’en a pas besoin.
<li>En combinant ces deux techniques, vous pouvez facilement construire des chemins pour les répertoires et fichiers dans le répertoire personnel de l’utilisateur. La fonction <code>os.path.join()</code> peut prendre autant de paramètres que nécessaire. J’étais aux anges quand j’ai découvert ceci, puisque <code>addSlashIfNecessary()</code> était une de ces stupides petites fonctions que je devais toujours écrire lorsque je construisais ma boîte à outils dans un nouveau langage. N’écrivez <em>pas</em> cette stupide petite fonction en Python&nbsp;: des personnes intelligentes s’en sont déjà chargées pour vous.
</ol>

<p><code>os.path</code> contient également des fonctions pour séparer les noms de chemins, de répertoires, et de fichiers en plusieurs parties.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pathname = '/Users/pilgrim/diveintopython3/examples/humansize.py'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>os.path.split(pathname)</kbd>                                        <span class=u>&#x2460;</span></a>
<samp class=pp>('/Users/pilgrim/diveintopython3/examples', 'humansize.py')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>(dirname, filename) = os.path.split(pathname)</kbd>                  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>dirname</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'/Users/pilgrim/diveintopython3/examples'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>filename</kbd>                                                       <span class=u>&#x2463;</span></a>
<samp class=pp>'humansize.py'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>(shortname, extension) = os.path.splitext(filename)</kbd>            <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>shortname</kbd>
<samp class=pp>'humansize'</samp>
<samp class=p>>>> </samp><kbd class=pp>extension</kbd>
<samp class=pp>'.py'</samp></pre>
<ol>
<li>La fonction <code>split</code> sépare un chemin complet et retourne un tuple contenant le chemin et le nom du fichier.
<li>Vous souvenez-vous de quand je vous ai dit d’utiliser <a href=native-datatypes.html#multivar>l’assignation à plusieurs variables</a> pour retourner plusieurs variables d’une fonction&nbsp;? La fonction <code>os.path.split()</code> fait exactement ça. Vous pouvez assigner la valeur de retour de la fonction <code>split</code> à un tuple (un <code>tuple</code> à deux éléments). Chacune des variables recevra la valeur de l’élément correspondant au tuple retourné.
<li>La première variable, <var>dirname</var>, reçoit la valeur du premier élément du tuple retourné par la fonction <code>os.path.split()</code>, le chemin du fichier.
<li>La seconde variable, <var>filename</var>, reçoit la valeur du second élément du tuple retourné par la fonction <code>os.path.split()</code>, le nom du fichier.
<li><code>os.path</code> contient également la fonction <code>os.path.splitext()</code>, qui sépare un nom de fichier et retourne un tuple contenant le nom du fichier et l’extension du fichier. Vous pouvez utiliser la même technique pour assigner chacun d’entre eux à des variables séparées.
</ol>

<h3 id=glob>Lister des Répertoires</h3>

<p>Le module <code>glob</code> est un autre outil de la bibliothèque standard de Python. C’est une façon simple de récupérer le contenu d’un répertoire programmatiquement, et d’utiliser le genre de jokers avec lesquels vous êtes probablement déjà familier(ère) si vous avez déjà utilisé la ligne de commande.

<aside>Le module <code>glob</code> utilise des jokers semblables à ceux d’un shell.</aside>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>os.chdir('/Users/pilgrim/diveintopython3/')</kbd>
<samp class=p>>>> </samp><kbd class=pp>import glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('examples/*.xml')</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>['examples\\feed-broken.xml',
 'examples\\feed-ns0.xml',
 'examples\\feed.xml']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>os.chdir('examples/')</kbd>                        <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('*test*.py')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=pp>['alphameticstest.py',
 'pluraltest1.py',
 'pluraltest2.py',
 'pluraltest3.py',
 'pluraltest4.py',
 'pluraltest5.py',
 'pluraltest6.py',
 'romantest1.py',
 'romantest10.py',
 'romantest2.py',
 'romantest3.py',
 'romantest4.py',
 'romantest5.py',
 'romantest6.py',
 'romantest7.py',
 'romantest8.py',
 'romantest9.py']</samp></pre>
<ol>
<li>Le module <code>glob</code> prend un schéma et retourne les chemins de tous les fichiers et répertoires qui y correspondent. Dans cet exemple, le joker est le chemin du répertoire plus «&nbsp;<code>*.xml</code>&nbsp;», ce qui correspond à tous les fichiers <code>.xml</code> dans le sous-répertoire <code>examples</code>.
<li>À présent, changeons le répertoire de travail pour qu’il soit <code>examples</code>. La fonction <code>os.chdir()</code> accepte les chemins relatifs.
<li>Vous pouvez inclure plusieurs jokers dans votre schéma glob. Cet exemple trouve tous les fichiers du répertoire de travail courant qui se terminent par l’extension <code>.py</code> et contiennent le mot <code>test</code> n’importe où dans leur nom.
</ol>

<h3 id=osstat>Récupérer les Méta-données d’un Fichier</h3>

<p>Tous les systèmes de fichiers modernes stockent des méta-données à propos de chaque fichier&nbsp;: date de création, de dernière modification, taille du fichier, etc. Python fournit une <abbr>API</abbr> unique pour accéder à ces méta-données. Vous n’avez pas besoin d’ouvrir le fichier&nbsp;: tout ce dont vous avez besoin est le nom du fichier.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                 <span class=u>&#x2460;</span></a>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata = os.stat('feed.xml')</kbd>     <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>metadata.st_mtime</kbd>                  <span class=u>&#x2462;</span></a>
<samp class=pp>1247520344.9537716</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import time</kbd>                        <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>time.localtime(metadata.st_mtime)</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=17,
  tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)</samp>
</pre>
<ol>
<li>Le répertoire de travail est le dossier <code>examples</code>.
<li><code>feed.xml</code> est un fichier du dossier <code>examples</code>. Appeler la fonction <code>os.stat()</code> retourne un objet qui contient différents types de méta-données à propos du fichier.
<li><code>st_mtime</code> est la date de dernière modification, mais dans un format qui n’est pas particulièrement utile. (Techniquement, c’est le nombre de secondes depuis Epoch, qui est défini comme la première seconde depuis le 1er janvier 1970. Sérieusement.)
<li>Le module <code>time</code> fait partie de la bibliothèque standard de Python. Il contient des fonctions pour convertir les différentes représentations du temps, formater des valeurs temporelles en chaines et gérer les fuseaux horaires.
<li>La fonction <code>time.localtime()</code> convertit une valeur temporelle de secondes-depuis-Epoch (à partir de la propriété <code>st_mtime</code> retournée par la fonction <code>os.stat()</code>) en une structure plus utile d’année, mois, jour, heure, minute, seconde, etc. Ce fichier a été modifié pour la dernière fois le 13 juillet 2009, vers 17h25.
</ol>

<pre class=screen>
# Poursuite de l’exemple précédent
<a><samp class=p>>>> </samp><kbd class=pp>metadata.st_size</kbd>                              <span class=u>&#x2460;</span></a>
<samp class=pp>3070</samp>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>humansize.approximate_size(metadata.st_size)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'3.0 KiB'</samp></pre>
<ol>
<li>La fonction <code>os.stat()</code> retourne aussi la taille du fichier, dans la propriété <code>st_size</code>. Le fichier <code>feed.xml</code> fait <code>3070</code> octets.
<li>Vous pouvez passer la propriété <code>st_size</code> à la fonction <a href=your-first-python-program.html#divingin><code>approximate_size()</code></a>.
</ol>

<h3 id=abspath>Construction de Chemins Absolus</h3>

<p>Dans <a href=#osstat>la section précédente</a>, la fonction <code>glob.glob()</code> retournait une liste de chemins relatifs. Le premier exemple avait des chemins tels que <code>'examples\feed.xml'</code>, et le second en avait des encore plus courts, tels que <code>'romantest1.py'</code>. Du moment que vous restez dans le même répertoire de travail, ces chemins relatifs fonctionneront pour ouvrir des fichiers ou accéder à leurs méta-données. Mais si vous voulez construire un chemin absolu&nbsp;&mdash;&nbsp;c’est-à-dire un qui inclut tous les noms de répertoires depuis la racine ou la lettre de lecteur&nbsp;&mdash;&nbsp;alors vous aurez besoin de la fonction <code>os.path.realpath()</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples</samp>
<samp class=p>>>> </samp><kbd class=pp>print(os.path.realpath('feed.xml'))</kbd>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples\feed.xml</samp></pre>

<p class=a>&#x2042;

<h2 id=listcomprehension>Listes En Compréhension</h2>

<aside>Vous pouvez utiliser n’importe quelle expression Python dans une liste en compréhension.</aside>

<p>Une <dfn>liste en compréhension</dfn> est une façon compacte de créer une liste à partir d’une autre en applicant une fonction à chacun des éléments de la liste.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = [1, 9, 8, 4]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[elem * 2 for elem in a_list]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>[2, 18, 16, 8]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                                  <span class=u>&#x2461;</span></a>
<samp class=pp>[1, 9, 8, 4]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = [elem * 2 for elem in a_list]</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp class=pp>[2, 18, 16, 8]</samp></pre>
<ol>
<li>Pour comprendre le sens de ceci, lisez-le de droite à gauche. <var>a_list</var> est la liste de départ. L’interpréteur Python parcourt la liste <var>a_list</var> élément par élément, assignant temporairement chaque élément à la variable <var>elem</var>. Python applique alors la fonction <code><var>elem</var> * 2</code> et ajoute le résultat à la liste retournée.
<li>Une liste en compréhension est une nouvelle liste et non une modification de la liste originale.
<li>Assigner le résultat d’une compréhension de liste à la variable d’origine est sans risque. Python construit la nouvelle liste en mémoire et, lorsque la nouvelle liste est complète, il assigne le résultat à la variable originale.
</ol>

<p>Vous pouvez utiliser n’importe quelle expression Python pour une liste en compréhension, y compris les fonctions définies dans le module <code>os</code> pour manipuler fichiers et répertoires.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('*.xml')</kbd>                                 <span class=u>&#x2460;</span></a>
<samp class=pp>['feed-broken.xml', 'feed-ns0.xml', 'feed.xml']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>[os.path.realpath(f) for f in glob.glob('*.xml')]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>['c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-broken.xml',
 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-ns0.xml',
 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed.xml']</samp>
</pre>
<ol>
<li>Ceci retourne une liste de tous les fichiers <code>.xml</code> dans le répertoire de travail.
<li>Cette liste en compréhension est construite à partir d’une liste de fichiers <code>.xml</code> transformés en chemins complets.
</ol>

<p>Les compréhensions de liste peuvent aussi filtrer des éléments, rendant le résultat plus petit que la liste originale.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[f for f in glob.glob('*.py') if os.stat(f).st_size > 6000]</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['pluraltest6.py',
 'romantest10.py',
 'romantest6.py',
 'romantest7.py',
 'romantest8.py',
 'romantest9.py']</samp>
</pre>
<ol>
<li>Pour filtrer une liste, vous pouvez inclure une clause <code>if</code> à la fin de la compréhension de liste. L’expression après le mot-clef <code>if</code> sera évaluée pour chaque élément de la liste. Si l’expression est évaluée à <code>True</code>, l’élément sera inclu dans la sortie. La compréhension de liste regardera la liste de tous les fichiers <code>.py</code> dans le répertoire courant, et l’expression <code>if</code> filtrera cette liste en testant si la taille de chaque fichier est supérieure à <code>6000</code> octets. Il y a six fichiers répondant à ces critères, donc la compréhension de liste retournera une liste de six noms de fichiers.
</ol>

<p>Jusqu’à présent, tous les exemples de listes par compréhension utilisaient des expressions simples&nbsp;&mdash;&nbsp;multiplier un nombre par une constante, appeler une unique fonction, ou retourner la liste originale (après filtrage). Mais il n’y a aucune limite à la complexité d’une compréhension de liste.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[(os.stat(f).st_size, os.path.realpath(f)) for f in glob.glob('*.xml')]</kbd>            <span class=u>&#x2460;</span></a>
<samp class=pp>[(3074, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-broken.xml'),
 (3386, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-ns0.xml'),
 (3070, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed.xml')]</samp>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[(humansize.approximate_size(os.stat(f).st_size), f) for f in glob.glob('*.xml')]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('3.0 KiB', 'feed-broken.xml'),
 ('3.3 KiB', 'feed-ns0.xml'),
 ('3.0 KiB', 'feed.xml')]</samp></pre>
<ol>
<li>Cette compréhension de liste trouve tous les fichiers <code>.xml</code> dans le répertoire de travail, récupère la taille de chaque fichier (en appelant la fonction <code>os.stat()</code>), et construit un tuple contenant à la fois la taille du fichier et le chemin absolu de celui-ci (en appelant la fonction <code>os.path.realpath()</code>).
<li>Cette compréhension se base sur la précédente en appelant la <a href=your-first-python-program.html#divingin>fonction <code>approximate_size()</code></a> avec la taille de chaque fichier <code>.xml</code>.
</ol>

<p class=a>&#x2042;

<h2 id=dictionarycomprehension>Dictionnaire en Compréhension</h2>

<p>Un <dfn>dictionaire en compréhension</dfn> est comme une liste en compréhension, mais c’est un dictionnaire qui est construit plutôt qu’une liste.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>metadata = [(f, os.stat(f)) for f in glob.glob('*test*.py')]</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>metadata[0]</kbd>                                                     <span class=u>&#x2461;</span></a>
<samp class=pp>('alphameticstest.py', nt.stat_result(st_mode=33206, st_ino=0, st_dev=0,
 st_nlink=0, st_uid=0, st_gid=0, st_size=2509, st_atime=1247520344,
 st_mtime=1247520344, st_ctime=1247520344))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict = {f:os.stat(f) for f in glob.glob('*test*.py')}</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>type(metadata_dict)</kbd>                                             <span class=u>&#x2463;</span></a>
<samp>&lt;class 'dict'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(metadata_dict.keys())</kbd>                                      <span class=u>&#x2464;</span></a>
<samp class=pp>['romantest8.py', 'pluraltest1.py', 'pluraltest2.py', 'pluraltest5.py',
 'pluraltest6.py', 'romantest7.py', 'romantest10.py', 'romantest4.py',
 'romantest9.py', 'pluraltest3.py', 'romantest1.py', 'romantest2.py',
 'romantest3.py', 'romantest5.py', 'romantest6.py', 'alphameticstest.py',
 'pluraltest4.py']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict['alphameticstest.py'].st_size</kbd>                     <span class=u>&#x2465;</span></a>
<samp class=pp>2509</samp></pre>
<ol>
<li>Ce n’est pas un dictionnaire en compréhension&nbsp;; c’est une <a href=#listcomprehension>liste en compréhension</a>. La définition prend tous les fichiers <code>.py</code> avec <code>test</code> dans leur nom, puis construit un tuple avec le nom du fichier et les méta-données de celui-ci (obtenues en appelant la fonction <code>os.stat()</code>).
<li>Chaque élément de la liste résultat est un tuple.
<li>Ceci est un dictionnaire construit par compréhension. La syntaxe est similaire à celle utilisée pour les listes, à deux différences près. D’abord, des accolades sont utilisées à la place des crochets pour encadrer l’expression. Ensuite, à la place d’une expression pour chaque élément, il y en a deux, séparées par un double point. L’expression avant le double point (<code>f</code> dans cet exemple) est une clef du dictionnaire&nbsp;; l’expression après le double point (<code>os.stat(f)</code> dans cet exemple) est la valeur associée.
<li>Un dictionnaire en compréhension est un dictionnaire.
<li>Les clefs de ce dictionnaire sont simplement les noms de fichier retournés par l’appel à <code>glob.glob('*test*.py')</code>.
<li>La valeur associée à chaque clef est la valeur retournée par la fonction <code>os.stat()</code>. Cela signifie que l’on peut «&nbsp;rechercher&nbsp;» un fichier par son nom dans ce dictionnaire et obtenir ses méta-données. L’une de ces méta-données est la taille du fichier. Le fichier <code>alphameticstest.py</code> fait <code>2509</code> octets.
</ol>

<p>Comme pour les listes par compréhension, vous pouvez inclure une clause <code>if</code> dans une compréhension de dictionnaire afin de filtrer la séquence de départ basée sur une expression évaluée pour chaque élément.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob, humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict = {f:os.stat(f) for f in glob.glob('*')}</kbd>                                  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>humansize_dict = {os.path.splitext(f)[0]:humansize.approximate_size(meta.st_size) \     </kbd>
<samp class=p>... </samp><kbd class=pp>                  for f, meta in metadata_dict.items() if meta.st_size > 6000}</kbd>          <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>list(humansize_dict.keys())</kbd>                                                             <span class=u>&#x2462;</span></a>
<samp class=pp>['romantest9', 'romantest8', 'romantest7', 'romantest6', 'romantest10', 'pluraltest6']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>humansize_dict['romantest9']</kbd>                                                            <span class=u>&#x2463;</span></a>
<samp class=pp>'6.5 KiB'</samp></pre>
<ol>
<li>Ce dictionnaire en compréhension est construit à partir d’une liste de tous les fichiers dans le répertoire de travail (<code>glob.glob('*')</code>), à laquelle sont associées les méta-données de chaque fichier (<code>os.stat(f)</code>).
<li>Cette définition est construite à partir de la première, filtrant les fichiers qui font moins de <code>6000</code> octets (<code>if meta.st_size > 6000</code>), et utilise cette liste filtrée pour construire un dictionnaire dont les clefs sont les noms de fichiers auxquels on a retiré l’extension (<code>os.path.splitext(f)[0]</code>) et dont les valeurs sont la taille approximative de chacun de ces fichiers (<code>humansize.approximate_size(meta.st_size)</code>).
<li>Comme vous l’avez vu dans l’exemple précédent, il y a six fichiers correspondants. Ainsi, il y a six éléments dans le dictionnaire.
<li>La valeur associée à chacune des clefs est la chaine retournée par la fonction <code>approximate_size()</code>.
</ol>

<h3 id=stupiddicttricks>D’Autres Choses Amusantes À Faire Avec Les Définitions De Dictionnaires En Compréhension</h3>

<p>Voici une astuce avec les dictionnaires définis par compréhension qui peut vous être utile un jour&nbsp;: échanger les clefs et les valeurs d’un dictionnaire.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict = {'a': 1, 'b': 2, 'c': 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>{value:key for key, value in a_dict.items()}</kbd>
<samp class=pp>{1: 'a', 2: 'b', 3: 'c'}</samp></pre>

<p>Bien sûr, cela ne marche que si les valeurs du dictionnaire sont immuables, comme des chaines ou des tuples. Si vous essayez ceci avec un dictionnaire qui contient des listes, cela échouera spectaculairement.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict = {'a': [1, 2, 3], 'b': 4, 'c': 5}</kbd>
<samp class=p>>>> </samp><kbd class=pp>{value:key for key, value in a_dict.items()}</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 1, in &lt;dictcomp>
TypeError: unhashable type: 'list'</samp></pre>

<p class=a>&#x2042;

<h2 id=setcomprehension>Ensembles Définis En Compréhension</h2>

<p>Sans les oublier, les ensembles ont leur propre syntaxe pour les définir par compréhension. Elle est remarquablement similaire à la syntaxe utilisée pour les dictionnaires. La seule différence est qu’il n’y a que des valeurs au lieu de paires clef:valeur.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = set(range(10))</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{x ** 2 for x in a_set}</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{x for x in a_set if x % 2 == 0}</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>{0, 8, 2, 4, 6}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{2**x for x in range(10)}</kbd>         <span class=u>&#x2462;</span></a>
<samp class=pp>{32, 1, 2, 4, 8, 64, 128, 256, 16, 512}</samp>
</pre>
<ol>
<li>Les ensembles définis par compréhension peuvent prendre un autre ensemble comme entrée. La définition de l’ensemble calcule le carré de tous les éléments de l’ensemble de <code>0</code> à <code>9</code>.
<li>Comme les définitions par compréhension de listes et de dictionnaires, celles de dictionnaires peuvent contenir une clause <code>if</code> pour filtrer les éléments avant de les retourner dans l’ensemble de résultats.
<li>Une définition par compréhension d’ensemble n’a pas nécessairement besoin d’un autre ensemble comme entrée&nbsp;: une séquence suffit.
</ol>

<p class=a>&#x2042;

<h2 id=furtherreading>Aller Plus Loin</h2>
<ul>
<li><a href=http://docs.python.org/3.1/library/os.html>Le module <code>os</code></a>
<li><a href=http://www.doughellmann.com/PyMOTW/os/><code>os</code>&nbsp;&mdash;&nbsp;Accès portable à des fonctionnalités spécifiques à certains systèmes d’exploitation</a>
<li><a href=http://docs.python.org/3.1/library/os.path.html>Le module <code>os.path</code></a>
<li><a href=http://www.doughellmann.com/PyMOTW/ospath/><code>os.path</code>&nbsp;&mdash;&nbsp;Manipulation de noms de fichiers indépendante de la plateforme</a>
<li><a href=http://docs.python.org/3.1/library/glob.html>Le module <code>glob</code></a>
<li><a href=http://www.doughellmann.com/PyMOTW/glob/><code>glob</code>&nbsp;&mdash;&nbsp;Schémas de noms de fichiers</a>
<li><a href=http://docs.python.org/3.1/library/time.html>Le module <code>time</code></a>
<li><a href=http://www.doughellmann.com/PyMOTW/time/><code>time</code>&nbsp;&mdash;&nbsp;Des fonctions pour manipuler l’horloge</a>
<li><a href=http://docs.python.org/3.1/tutorial/datastructures.html#list-comprehensions>Listes définies par compréhensions</a>
<li><a href=http://docs.python.org/3.1/tutorial/datastructures.html#nested-list-comprehensions>Listes imbriquées définies par compréhensions</a>
<li><a href=http://docs.python.org/3.1/tutorial/datastructures.html#looping-techniques>Techniques de boucles</a>
</ul>
<p class=v><a href=native-datatypes.html rel=prev title='retourner à &#8220;Types Prédéfinis&#8221;'><span class=u>&#x261C;</span></a> <a href=strings.html rel=next title='aller à &#8220;Chaines&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
