---
title: Classes <i class=baa>&amp;</i> Itérateurs
status: Relecture
permalink: iterators.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Classes &amp; Itérateurs - Plongez dans Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 7}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Vous êtes ici&nbsp;: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#iterators>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Difficulté&nbsp;: <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Classes <i class=baa>&amp;</i> Itérateurs</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> L’Orient et l’Occident&nbsp;: deux mondes qui jamais ne pourront se rejoindre <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Rudyard_Kipling>Rudyard Kipling</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Plongée</h2>
<p class=f>Les itérateurs sont la «&nbsp;sauce secrète&nbsp;» de Python 3. Ils sont partout, sous-jacents à tout, mais toujours hors de vue. <a href=comprehensions.html>Les compréhensions</a> sont juste une forme simple d’<i>itérateurs</i>. Les générateurs sont juste une forme simple d’<i>itérateurs</i>. Une fonction qui <code>yield</code> (cède) des valeurs est un moyen correct et compact de construire un itérateur sans construire d’itérateur. Laissez-moi vous montrer ce que je veux dire par là.

<p>Vous rappelez-vous du <a href=generators.html#a-fibonacci-generator>générateur Fibonacci</a>&nbsp;? Voici un itérateur écrit à partir de zéro&nbsp;:

<p class=d>[<a href=examples/fibonacci2.py>télécharger <code>fibonacci2.py</code></a>]
<pre class=pp><code>class Fib:
    '''iterator that yields numbers in the Fibonacci sequence'''

    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.a = 0
        self.b = 1
        return self

    def __next__(self):
        fib = self.a
        if fib > self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b
        return fib</code></pre>

<p>Analysons ce code ligne par ligne.

<pre class='nd pp'><code>class Fib:</code></pre>

<p><code>class</code>? Qu’est-ce qu’une classe&nbsp;?

<p class=a>&#x2042;

<h2 id=defining-classes>Définition des Classes</h2>

<p>Python est entièrement orienté objet&nbsp;: vous pouvez définir vos propres classes, hériter de vos propres classes ou de classes intégrées, et instancier les classes que vous avez définies.

<p>Définir une classe en Python est simple. Comme les fonctions, il n’existe pas de définition spécifique de l’interface. Il suffit de définir la classe et de commencer à coder. Une classe Python commence par le mot réservé <code>class</code>, suivi du nom de la classe. Techniquement, c’est tout ce qui est nécessaire, car une classe n’a pas besoin d’hériter d’une autre classe.

<pre class=pp><code><a>class PapayaWhip:  <span class=u>&#x2460;</span></a>
<a>    pass           <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Le nom de cette classe est <code>PapayaWhip</code>, et elle n’hérite pas d’une autre classe. Les noms de classes sont habituellement capitalisés, <code>ChaqueMotCommeCeci</code>, mais ce n’est qu’une convention, pas une obligation.
<li>Vous l’aurez sans doute deviné, mais tout dans une classe est indenté, tout comme le code dans une fonction, bloc <code>if</code>, boucle <code>for</code>, ou tout autre bloc de code. La première ligne non indentée est en dehors de la classe.
</ol>

<p><code>PapayaWhip</code> ne définit aucune méthode ni attribut, mais syntaxiquement, il doit y avoir quelque chose dans la définition, d’où l’utilisation de <code>pass</code>. Il s’agit d’un mot réservé de Python qui signifie simplement «&nbsp;Circulez, rien à voir ici.&nbsp;» C’est une déclaration qui ne fait rien, et c’est un bon marqueur lorsque vous écrivez un squelette de fonction ou de classe.

<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>La déclaration <code>pass</code> en Python est comme un ensemble vide d’accolades (<code>{}</code>) en Java ou C.
</blockquote>

<p>De nombreuses classes sont héritées d’autres classes, mais celle-ci ne l’est pas. De nombreuses classes définissent des méthodes, mais celle-ci ne le fait pas. Il n’y a rien qu’une classe Python doit absolument avoir en dehors d’un nom. En particulier, les programmeurs C++ s’étonneront sans doute que les classes Python n’aient pas de constructeurs et de destructeurs explicites. Bien qu’ils ne soient pas obligatoires, les classes Python <em>peuvent</em> avoir quelque chose de semblable à un constructeur&nbsp;: la méthode <code>__init__()</code>.

<h3 id=init-method>La méthode <code>__init__()</code></h3>

<p>Cet exemple montre l’initialisation de la classe <code>Fib</code> avec la méthode <code>__init__</code>.

<pre class=pp><code>class Fib:
<a>    '''iterator that yields numbers in the Fibonacci sequence'''  <span class=u>&#x2460;</span></a>

<a>    def __init__(self, max):                                      <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Les classes peuvent (et devraient) aussi avoir une <code>docstring</code>, tout comme les modules et les fonctions.
<li>La méthode <code>__init__()</code> est appelée immédiatement après qu’une instance de la classe ait été créée. Il serait tentant&nbsp;&mdash;&nbsp;mais techniquement incorrect&nbsp;&mdash;&nbsp;de l’appeler le «&nbsp;constructeur&nbsp;» de la classe. Il est tentant, parce qu’il ressemble à un constructeur C++ (par convention, la méthode <code>__init__()</code> est la première méthode définie pour la classe), agit comme un constructeur (c’est le premier morceau de code exécuté lors de la création d’une nouvelle instance de la classe), et sonne pareil. Incorrect, car l’objet a déjà été construit au moment où le <code>__init__()</code> est appelé, et vous avez déjà une référence valide à la nouvelle instance de la classe.
</ol>

<p>Le premier argument de chaque méthode de la classe, y compris la méthode <code>__init__()</code>, est toujours une référence à l’instance actuelle de la classe. Par convention, cet argument est nommé <var>self</var>. Cet argument remplit le rôle du mot réservé <code>this</code> dans <abbr>C++</abbr> ou Java, mais <var>self</var> n’est pas un mot réservé de Python, seulement une convention de nommage. Cependant, veuillez ne pas l’appeler autrement que <var>self</var>&nbsp;: c’est une convention très forte.

<p>Dans toutes les méthodes de classe, <var>self</var> se réfère à l’instance dont la méthode a été appelée. Mais dans le cas spécifique de la méthode <code>__init__()</code>, l’instance dont la méthode a été appelée est également l’objet nouvellement créé. Bien que vous deviez spécifier <var>self</var> explicitement lorsque vous définissez la méthode, vous <em>n’</em>avez <em>pas</em> à le spécifier lorsque vous appelez la méthode&nbsp;: Python l’ajoutera automatiquement pour vous.

<p class=a>&#x2042;

<h2 id=instantiating-classes>Instantiation de Classes</h2>

<p>L’instanciation de classes en Python est simple. Pour instancier une classe, appelez simplement la classe comme si elle était une fonction, en passant les arguments que le <code>__init__()</code> a besoin. La valeur de retour sera l’objet nouvellement créé.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import fibonacci2</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>fib = fibonacci2.Fib(100)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>fib</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;fibonacci2.Fib object at 0x00DB8810></samp>
<a><samp class=p>>>> </samp><kbd class=pp>fib.__class__</kbd>              <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'fibonacci2.Fib'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>fib.__doc__</kbd>                <span class=u>&#x2463;</span></a>
<samp class=pp>'iterator that yields numbers in the Fibonacci sequence'</samp></pre>
<ol>
<li>Vous créez une instance de la classe <code>Fib</code> (définie dans le module <code>fibonacci2</code>) et assignez l’instance nouvellement créée à la variable <var>fib</var>. Nous passons un paramètre, <code>100</code>, qui finira comme l’argument <var>max</var> dans la méthode <code>__init__()</code> de <code>Fib</code>.
<var>fib</var> est maintenant une instance de la classe <code>Fib</code>.
<li>Chaque instance de classe a un attribut prédéfini, <code>__class__</code>, qui est la classe de l’objet. Les programmeurs Java sont sans doute familiers de la classe <code>Class</code>, qui contient des méthodes comme <code>getName()</code> et <code>getSuperclass()</code> pour obtenir des informations de méta-données relatives à un objet. En Python, ce genre de méta-données est disponible par le biais des attributs, mais l’idée est la même.
Vous pouvez accéder à l’instance <code>docstring</code> comme pour une fonction ou un module. Toutes les instances d’une classe partagent la même <code>docstring</code>.
<li>Chaque instance de classe a un attribut prédéfini, <code>__class__</code>, qui est la classe de l’objet. Les programmeurs-euses Java peuvent être familiers-ères avec la classe <code>Class</code>, qui contient des méthodes telles qui <code>getName()</code> et <code>getSuperclass()</code> pour obtenir des métadonnées à propos de l’objet. En Python, ces métadonnées sont accessibles via des attributs, mais l’idée est la même.
<li>Vous pouvez accéder à la <code>docstring</code> de l’instance comme pour une fonction ou un module. Toutes les instances de la classe partagent la même <code>docstring</code>.

</ol>

<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>En Python, appelez simplement une classe comme s’il s’agissait d’une fonction pour créer une nouvelle instance de la classe. Il n’y a pas d’opérateur explicite <code>new</code> comme dans <abbr>C++</abbr> ou Java.
</blockquote>

<p class=a>&#x2042;

<h2 id=instance-variables>Instancier des Variables</h2>

<p>Sur la ligne suivante&nbsp;:

<pre class=pp><code>class Fib:
    def __init__(self, max):
<a>        self.max = max        <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>Qu’est-ce que <var>self.max</var>&nbsp;? C’est une variable d’instance. Elle est complètement séparée de <var>max</var>, qui a été adopté dans le <code>__init__()</code> comme argument. <var>self.max</var> est «&nbsp;global&nbsp;» à l’instance. Cela signifie que vous pouvez y accéder à partir d’autres méthodes.
</ol>

<pre class=pp><code>class Fib:
    def __init__(self, max):
<a>        self.max = max        <span class=u>&#x2460;</span></a>
    .
    .
    .
    def __next__(self):
        fib = self.a
<a>        if fib > self.max:    <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li><var>self.max</var> est défini dans la méthode <code>__init__()</code>&hellip;
<li>&hellip;et référencé dans la méthode <code>__next__()</code>.
</ol>

<p>Les variables d’instance sont spécifiques à une instance d’une classe. Par exemple, si vous créez deux instances de <code>Fib</code> avec des valeurs maximales différentes, elles se souviendront chacune de leurs propres valeurs.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import fibonacci2</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib1 = fibonacci2.Fib(100)</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib2 = fibonacci2.Fib(200)</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib1.max</kbd>
<samp class=pp>100</samp>
<samp class=p>>>> </samp><kbd class=pp>fib2.max</kbd>
<samp class=pp>200</samp></pre>

<p class=a>&#x2042;

<h2 id=a-fibonacci-iterator>Un itérateur Fibonacci</h2>

<p><em>Maintenant</em> vous êtes prêt à apprendre à construire un itérateur. Un itérateur est simplement une classe qui définit un <code>__iter__()</code>.

<aside class=ots>
Chacune de ces trois méthodes de classe, <code>__init__</code>,<code>__iter__</code>, et <code>__next__</code>, commencent et finissent avec une paire de caractères underscore (<code>_</code>). Pourquoi&nbsp;? Il n’y a rien de magique, mais cela indique généralement que ce sont des «&nbsp;<dfn>méthodes spéciales</dfn>&nbsp;». La seule chose «&nbsp;spéciale&nbsp;» sur les méthodes spéciales, c’est qu’elles ne sont pas appelées directement&nbsp;: Python les appelle lorsque vous utilisez une autre syntaxe ou  instance de la classe. <a href=special-method-names.html>Davantage sur les méthodes spéciales</a>.
</aside>

<p class=d>[<a href=examples/fibonacci2.py>télécharger <code>fibonacci2.py</code></a>]
<pre class=pp><code><a>class Fib:                                        <span class=u>&#x2460;</span></a>
<a>    def __init__(self, max):                      <span class=u>&#x2461;</span></a>
        self.max = max

<a>    def __iter__(self):                           <span class=u>&#x2462;</span></a>
        self.a = 0
        self.b = 1
        return self

<a>    def __next__(self):                           <span class=u>&#x2463;</span></a>
        fib = self.a
        if fib > self.max:
<a>            raise StopIteration                   <span class=u>&#x2464;</span></a>
        self.a, self.b = self.b, self.a + self.b
<a>        return fib                                <span class=u>&#x2465;</span></a></code></pre>
<ol>
<li>Pour construire un itérateur à partir de zéro, <code>Fib</code> doit être une classe, pas une fonction.
<li>«&nbsp;Appeler&nbsp;» <code>Fib(max)</code> crée vraiment une instance de cette classe et appelle sa méthode <code>__init__()</code> avec <var>max</var>. La méthode <code>__init__()</code> enregistre la valeur maximale comme une variable d’instance afin que d’autres méthodes puissent s’y référer plus tard.
<li>La méthode <code>__iter__()</code> est appelée chaque fois que quelqu’un appelle <code>iter(fib)</code>. (Comme vous le verrez dans une minute, une boucle <code>for</code> l’appellera automatiquement, mais vous pouvez également l’appeler vous-même manuellement). Après avoir effectué l’initialisation de début de l’itération (dans ce cas, la réinitialisation de <code>self.a</code> et <code>self.b</code>, nos deux compteurs), la méthode <code>__iter__()</code> peut retourner n’importe quel objet qui implémente une méthode <code>__next__()</code>. Dans ce cas (et dans la plupart des cas), <code>__iter__()</code> renvoie simplement <var>self</var>, puisque cette classe implémente sa propre méthode <code>__next__()</code>.
<li>La méthode <code>__next__()</code> est appelée chaque fois que quelqu’un appelle <code>next()</code> sur un itérateur d’une instance d’une classe. Cela fera plus de sens dans une minute.
<li>Lorsque la méthode <code>__next__()</code> soulève une exception <code>StopIteration</code>, cela indique à l’appelant que l’itération est épuisée. Contrairement à la plupart des exceptions, ce n’est pas une erreur, c’est une condition normale qui signifie simplement que l’itérateur n’a plus de valeurs à générer. Si l’appelant est une boucle <code>for</code>, il saura remarqué cette exception <code>StopIteration</code> et sortir gracieusement de la boucle. (En d’autres termes, il va avaler l’exception.) Ce peu de magie est en fait la clé de l’utilisation des itérateurs dans des boucles <code>for</code>.
<li>Pour cracher la valeur suivante, une méthode <code>__next__()</code> de l’itérateur <code>retourne</code> simplement la valeur. N’utilisez pas <code>yield</code> ici, c’est un peu de sucre syntaxique qui s’applique uniquement lorsque vous utilisez les générateurs. Ici, vous créez votre propre itérateur à partir de zéro&nbsp;: utilisez plutôt <code>return</code>.
</ol>

<p>Pas encore perdu-e&nbsp;? Excellent. Voyons comment appeler cet itérateur&nbsp;:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>from fibonacci2 import Fib</kbd>
<samp class=p>>>> </samp><kbd class=pp>for n in Fib(1000):</kbd>
<samp class=p>... </samp><kbd class=pp>    print(n, end=' ')</kbd>
<samp class=pp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>

<p>Eh bien, c’est exactement la même chose&nbsp;! C’est identique octet par octet à la façon dont vous avez appelé <a href=generators.html#a-fibonacci-generator>Fibonacci-comme-un-générateur</a> (modulo une majuscule). Mais comment&nbsp;?

<p>Il y a un peu de magie impliquée dans les boucles <code>for</code>. Voici ce qui arrive&nbsp;:

<ul>
<li>La boucle <code>for</code> appelle <code>Fib(1000)</code>, comme indiqué. Ceci retourne une instance de la classe <code>Fib</code>. Appelons-la <var>fib_inst</var>.
<li>Secrètement, et assez habilement, la boucle <code>for</code> appelle <code>iter(fib_inst)</code>, qui renvoie un objet itérateur. Appelons-la <var>fib_iter</var>. Dans ce cas, <var>fib_iter</var> == <var>fib_inst</var>, parce que la méthode <code>__iter__()</code> retourne <var>self</var>, mais la boucle <code>for</code> ne sait rien (ou ne se préoccupe pas) à ce sujet.
<li>Pour «&nbsp;boucler à l’intérieur&nbsp;» de l’itérateur, la boucle <code>for</code> appelle <code>next(fib_iter)</code>, qui appelle la méthode <code>__next__()</code> sur l’objet <code>fib_iter</code>, qui effectue les calculs du prochain nombre de Fibonacci et renvoie une valeur. La boucle <code>for</code> prend cette valeur, l’assigne à <var>n</var>, puis exécute le corps de la boucle <code>for</code> pour cette valeur de <var>n</var>.
<li>Comment la boucle <code>for</code> sait quand s’arrêter&nbsp;? Je suis content que vous posiez la question&nbsp;! Quand <code>next(fib_iter)</code> soulève une exception <code>StopIteration</code>, la boucle <code>for</code> va avaler l’exception et se terminer normalement. (Toute autre exception va passer à travers et sera soulevée comme d’habitude.) Et où avez-vous vu une exception <code>StopIteration</code>&nbsp;? Dans la méthode <code>__next__()</code>, bien sûr&nbsp;!
</ul>

<p class=a>&#x2042;

<h2 id=a-plural-rule-iterator>Un itérateur d’accord au pluriel</h2>

<aside>iter(f) appelle f.__iter__<br>next(f) appelle f.__next__</aside>
<p>Voici venu le temps du final. Réécrivons le <a href=generators.html>générateur de règles pour le pluriel</a> comme un itérateur.

<p class=d>[<a href=examples/plural6.py>télécharger <code>plural6.py</code></a>]
<pre class=pp><code>class LazyRules:
    rules_filename = 'plural6-rules.txt'

    def __init__(self):
        self.pattern_file = open(self.rules_filename, encoding='utf-8')
        self.cache = []

    def __iter__(self):
        self.cache_index = 0
        return self

    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
            return self.cache[self.cache_index - 1]

        if self.pattern_file.closed:
            raise StopIteration

        line = self.pattern_file.readline()
        if not line:
            self.pattern_file.close()
            raise StopIteration

        pattern, search, replace = line.split(None, 3)
        funcs = build_match_and_apply_functions(
            pattern, search, replace)
        self.cache.append(funcs)
        return funcs

rules = LazyRules()</code></pre>

<p>Voici une classe qui implémente <code>__iter__()</code> et <code>__next__()</code>, de manière à pouvoir être utilisé comme un itérateur. Ensuite, vous instanciez la classe et l’assignez à <var>rules</var>. Ça ne se fait qu’une fois, à l’import.

<p>Analysons cette classe, morceau par morceau.

<pre class=pp><code>class LazyRules:
    rules_filename = 'plural6-rules.txt'

    def __init__(self):
<a>        self.pattern_file = open(self.rules_filename, encoding='utf-8')  <span class=u>&#x2460;</span></a>
<a>        self.cache = []                                                  <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Nous instancions la classe <code>LazyRules</code>, ouvrons le fichier de règles mais ne le lisons pas. (Ça viendra plus tard.)
<li>Après avoir ouvert le fichier de règles, initialisons le cache. Vous utiliserez ce cache plus tard (dans la méthode <code>__next__()</code>) lorsque vous lirez les lignes du fichier de règles.
</ol>

<p>Avant de continuer, nous allons jeter un coup d’œil de plus près à la variable <var>rules_filename</var>. Elle n’est pas définie dans le <code>__iter__()</code>. En fait, elle n’est définie dans <em>aucune</em> méthode. Elle est définie au niveau de la classe. Il s’agit d’une <i>variable de classe</i>, et bien que vous puissiez y accéder comme une variable d’instance (<var>self.rules_filename</var>), elle est partagée par toutes les instances de la classe <code>LazyRules</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import plural6</kbd>
<samp class=p>>>> </samp><kbd class=pp>r1 = plural6.LazyRules()</kbd>
<samp class=p>>>> </samp><kbd class=pp>r2 = plural6.LazyRules()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>                               <span class=u>&#x2460;</span></a>
<samp class=pp>'plural6-rules.txt'</samp>
<samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.rules_filename = 'r2-override.txt'</kbd>           <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>
<samp class=pp>'r2-override.txt'</samp>
<samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.__class__.rules_filename</kbd>                     <span class=u>&#x2462;</span></a>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.__class__.rules_filename = 'papayawhip.txt'</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>
<samp class=pp>'papayawhip.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>                               <span class=u>&#x2464;</span></a>
<samp class=pp>'r2-overridetxt'</samp></pre>
<ol>
<li>Chaque instance de la classe hérite de l’attribut <var>rules_filename</var> avec la valeur définie par la classe.
<li>Changer la valeur de l’attribut dans un cas n’affecte pas les autres cas&hellip; 
<li>&hellip;ni ne change l’attribut de classe. Vous pouvez accéder à l’attribut de classe (par opposition à l’attribut d’une instance individuelle) en utilisant l’attribut spécial <code>__class__</code> pour accéder à la classe elle-même.
<li>Si vous modifiez l’attribut de classe, toutes les instances qui héritent encore de cette valeur (comme <var>r1</var> ici) seront affectées.
<li>Les instances qui ont annulé cet attribut (comme <var>r2</var> ici) ne seront pas affectées.
</ol>

<p>Et maintenant, revenons à notre spectacle.

<pre class=pp><code><a>    def __iter__(self):       <span class=u>&#x2460;</span></a>
        self.cache_index = 0
<a>        return self           <span class=u>&#x2461;</span></a>
</code></pre>
<ol>
<li>La méthode <code>__iter__()</code> sera appelée à chaque fois que quelqu’un&nbsp;&mdash;&nbsp;disons une boucle <code>for</code>&nbsp;&mdash;&nbsp;appelle <code>iter(rules)</code>.
<li>La seule chose que chaque méthode <code>__iter__()</code> doit faire, c’est retourner un itérateur. Dans ce cas, il retourne <var>self</var>, qui signale que cette classe définit un <code>__next__()</code> qui va prendre soin de retourner les valeurs tout au long de l’itération.
</ol>

<pre class=pp><code><a>    def __next__(self):                                 <span class=u>&#x2460;</span></a>
        .
        .
        .
        pattern, search, replace = line.split(None, 3)
<a>        funcs = build_match_and_apply_functions(        <span class=u>&#x2461;</span></a>
            pattern, search, replace)
<a>        self.cache.append(funcs)                        <span class=u>&#x2462;</span></a>
        return funcs</code></pre>
<ol>
<li>La méthode <code>__next__()</code> sera appelée à chaque fois que quelqu’un&nbsp;&mdash;&nbsp;disons une boucle <code>for</code>&nbsp;&mdash;&nbsp;appelle <code>next(rules)</code>. Cette méthode n’a de sens que si nous commençons à la fin et travaillons à rebours. Faisons ça.
<li>Au moins la dernière partie de cette fonction devrait vous être familière. La fonction <code>build_match_and_apply_functions()</code> n’a pas changé&nbsp;: c’est toujours la même fonction.
<li>La seule différence est que, avant de retourner le match et les fonctions applicables (qui sont stockées dans le tuple <var>funcs</var>), nous allons les enregistrer dans <code>self.cache</code>.
</ol>

<p>Travaillons à reculons&hellip;

<pre class=pp><code>    def __next__(self):
        .
        .
        .
<a>        line = self.pattern_file.readline()  <span class=u>&#x2460;</span></a>
<a>        if not line:                         <span class=u>&#x2461;</span></a>
            self.pattern_file.close()
<a>            raise StopIteration              <span class=u>&#x2462;</span></a>
        .
        .
        .</code></pre>
<ol>
<li>Un peu de bidouillage avancé sur les fichiers ici. La méthode <code>readline()</code> (note&nbsp;: singulier, non au pluriel <code>readlines()</code>) lit exactement une ligne à partir d’un fichier ouvert. Plus précisément, la ligne suivante. (<em>Les objets fichier sont aussi des itérateurs&nbsp;! Ce sont des itérateurs tout le long&hellip;</em>)
<li>S’il y a une ligne à lire pour <code>readline()</code>, <var>line</var> ne sera pas une chaîne vide. Même si le fichier contient une ligne vide, <var>line</var> finirait comme une chaîne d’un caractère <code>'\n'</code> (un retour chariot). Si <var>line</var> est vraiment une chaîne vide, cela signifie qu’il n’y a plus de lignes à lire à partir du fichier.
<li>Lorsque nous arrivons à la fin du fichier, nous devrions fermer le fichier et soulever l’exception magique <code>StopIteration</code>. Rappelez-vous, nous sommes arrivés à ce point parce que nous avions besoin d’une fonction de correspondance et d’application pour la règle suivante. La règle suivante vient de la ligne suivante du fichier&hellip; mais il n’y a pas de ligne suivante&nbsp;! Par conséquent, nous n’avons aucune valeur à renvoyer. L’itération est terminée. (<span class=u>&#x266B;</span> La fête est terminée&hellip; <span class=u>&#x266B;</span>)
</ol>

<p>Travaillons à reculons vers le début de la méthode <code>__next__()</code>&hellip;

<pre class=pp><code>    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
<a>            return self.cache[self.cache_index - 1]     <span class=u>&#x2460;</span></a>

        if self.pattern_file.closed:
<a>            raise StopIteration                         <span class=u>&#x2461;</span></a>
        .
        .
        .</code></pre>
<ol>
<li><code>self.cache</code> sera une liste des fonctions dont nous avons besoin pour faire correspondre et appliquer des règles différentes. (Au moins <em>ceci</em> devrait vous paraître familier&nbsp;!) <code>self.cache_index</code> garde la trace des élément mis en cache que nous devrions retourner ensuite. Si nous n’avons pas encore épuisé le cache (<i>i.e.</i> si la longueur de <code>self.cache</code> est supérieure à <code>self.cache_index</code>), alors nous avons un cache hit&nbsp;! Hourra&nbsp;! Nous pouvons retourner la correspondance et appliquer des fonctions de la mémoire cache au lieu de les construire à partir de zéro.
<li>D’autre part, si nous n’obtenons pas un hit dans le cache, <em>et</em> que l’objet fichier a été fermé (ce qui pourrait se passer, plus bas dans la méthode, comme vous l’avez vu dans le précédent extrait de code), alors il n’y a rien que nous puissions faire. Si le fichier est fermé, cela signifie que nous avons épuisé&nbsp;&mdash;&nbsp;nous avons déjà lu chaque ligne du fichier de règles, et nous avons déjà construit et mis en cache la correspondance et appliqué des fonctions pour chaque règle. Le fichier est épuisé, le cache est épuisé, je suis épuisé. Attendez, quoi&nbsp;? Accrochez-vous, nous avons presque terminé.
</ol>

<p>En rassemblant tout ça, voici ce qui arrive quand&nbsp;:

<ul>
<li>Lorsque le module est importé, il crée une instance unique de la classe <code>LazyRules</code>, appelée <var>rules</var>, qui ouvre le fichier de règles, mais ne le lit pas.
<li>Lorsqu’il est interrogé pour la première correspondance et l’application de fonction, il vérifie son cache, mais trouve le cache vide. Alors il lit une seule ligne dans le fichier de règles, construit la correspondance, applique les fonctions de cette règle et les met en cache.
<li>Disons que, pour les besoins du raisonnement, la première règle correspond. Si c’est le cas, aucune autre correspondance ni application de fonctions n’est construit, et aucune autre ligne n’est lue à partir du fichier de règles.
<li>En outre, pour les besoins du raisonnement, supposons que l’appelant appelle la fonction <code>plural()</code> <em>à nouveau</em> afin de mettre au pluriel un mot différent. La boucle <code>for</code> dans la fonction <code>plural()</code> appellera <code>iter(rules)</code>, qui permet de réinitialiser l’index du cache, mais pas de réinitialiser le fichier objet ouvert.
<li>La première fois, la boucle <code>for</code> demandera une valeur de <var>rules</var>, qui invoquera la méthode <code>__next__()</code>. Cette fois, cependant, le cache est apprêté avec une seule paire de correspondances et appliquera les fonctions, correspondant à la règle de la première ligne du fichier de règles. Depuis qu’ils ont été construits et mis en cache pour mettre au pluriel le mot précédent, ils sont récupérés à partir du cache. L’indice de cache est incrémenté, et le fichier ouvert n’est jamais touché.
<li>Disons que, pour les besoins du raisonnement, la première règle <em>ne</em> correspond <em>pas</em> cette fois-ci. Ainsi, la boucle <code>for</code> est à nouveau lancée et demande une autre valeur de <var>rules</var>. Ceci invoque la méthode <code>__next__()</code> une seconde fois. Cette fois, le cache est épuisé&nbsp;&mdash;&nbsp;il ne contenait qu’un élément, et nous l’interrogeons pour un second&nbsp;&mdash;&nbsp;donc le <code>__next__()</code> continue. Il lit une autre ligne du fichier ouvert, construit la correspondance et applique les fonctions sur les règles et les caches.
<li>Ce processus de lecture-construction-et-cache se poursuivra aussi longtemps que les règles lues à partir du fichier de règles ne correspondent pas avec le mot que nous essayons de mettre au pluriel. Si nous trouvons une règle de correspondance avant la fin du fichier, nous l’utilisons et arrêtons tout, avec le fichier toujours ouvert. Le pointeur de fichier va rester là où nous nous sommes arrêtés de lire, en attendant la commande <code>readline()</code> suivante. En attendant, le cache a maintenant davantage d’éléments dedans, et si nous recommençons tout en essayant de mettre au pluriel un nouveau mot, chacun des éléments restants dans le cache sera testé avant de lire la ligne suivante dans le fichier de règles.
</ul>

<p>Nous avons atteint le nirvana de la pluralisation.

<ol>
<li><strong>Coût de démarrage minimal.</strong> La seule chose qui se passe dans <code>import</code> est l’instanciation d’une seule classe et l’ouverture d’un fichier (mais pas la lecture de celui-ci).
<li><strong>Performances maximales.</strong> L’exemple précédent lit le fichier et construit les fonctions dynamiquement à chaque fois que vous voulez mettre un mot au pluriel. Cette version met en cache les fonctions dès qu’ells sont construites, et dans le pire des cas, il ne fera que lire le fichier de règles une fois, peu importe combien de mots vous souhaitez mettre au pluriel.
<li><strong>Séparation du code et des données.</strong> Toutes les règles sont stockées dans un fichier séparé. Le code est du code, et les données sont des données, et jamais ils ne se rencontreront.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Est-ce vraiment le nirvana&nbsp;? Eh bien, oui et non. Voici quelque chose à considérer avec l’exemple <code>LazyRules</code>&nbsp;: le fichier de règles est ouvert (pendant <code>__init__()</code>), et il reste ouvert jusqu’à ce que la dernière règle soit atteinte. Python finira par fermer le fichier quand il se termine, ou après que la dernière instanciation de la classe <code>LazyRules</code> soit détruite, ce qui pourrait prendre un <em>long</em> moment. Si cette classe fait partie d’un processus Python de longue durée, l’interpréteur Python peut ne jamais quitter, et l’objet <code>LazyRules</code> peut ne jamais être détruit.
<p>Il y a des façons de contourner cela. Au lieu d’ouvrir le fichier pendant <code>__init__()</code> et le laisser ouvert pendant que vous lisez les règles une ligne à la fois, vous pouvez ouvrir le fichier, lire toutes les règles, et fermer immédiatement le fichier. Ou vous pouvez ouvrir le fichier, lire une règle, enregistrer la position de fichier avec la <a href=files.html#read>méthode <code>tell()</code></a>, fermer le fichier, et plus tard ré-ouvrir et utiliser la <a href=files.html#read>méthode <code>seek()</code></a> pour poursuivre la lecture là où vous l’aviez laissée. Ou vous pourriez ne pas vous inquiéter à ce sujet et laisser le fichier ouvert, comme le fait cet exemple de code. La programmation est de la conception, et la conception est tout au sujet des arbitrages et des contraintes. Laisser une image ouverte trop longtemps pourrait être un problème&nbsp;; rendre votre code plus complexe pourrait être un problème. Lequel est le plus gros problème dépend de votre équipe de développement, votre application et votre environnement d’exécution.
</blockquote>

<p class=a>&#x2042;

<h2 id=furtherreading>Lectures complémentaires</h2>
<ul>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#iterator-types>Iterator types</a>
<li><a href=http://www.python.org/dev/peps/pep-0234/>PEP 234: Iterators</a>
<li><a href=http://www.python.org/dev/peps/pep-0255/>PEP 255: Simple Generators</a>
<li><a href=http://www.dabeaz.com/generators/>Generator Tricks for Systems Programmers</a>
</ul>

<p class=v><a href=generators.html rel=prev title='retourner à «&nbsp;Fermetures &amp; Générateurs&nbsp;»'><span class=u>&#x261C;</span></a> <a href=advanced-iterators.html rel=next title='aller à «&nbsp;Itérateurs avancés&nbsp;»'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
